<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>凉城</title><link>https://zhangleijuly.me/</link><description>Recent content on 凉城</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 24 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://zhangleijuly.me/index.xml" rel="self" type="application/rss+xml"/><item><title>LeetCode每日一题周总结(八)</title><link>https://zhangleijuly.me/p/leetcode-weekly-8/</link><pubDate>Fri, 24 Dec 2021 00:00:00 +0000</pubDate><guid>https://zhangleijuly.me/p/leetcode-weekly-8/</guid><description>&lt;img src="https://zhangleijuly.me/img/LeetCode.jpeg" alt="Featured image of post LeetCode每日一题周总结(八)" />&lt;h2 id="minimum-absolute-difference">Minimum Absolute Difference&lt;/h2>
&lt;p>略。&lt;/p>
&lt;h2 id="power-of-two">Power of Two&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/power-of-two/" target="_blank" rel="noopener"
>Power of Two&lt;/a>题目大意：判断一个整数是不是2的幂。&lt;/p>
&lt;p>题目很简单，可以用递归或者循环一路判断加除2。但是其他的方法也值得说道说道，一种方法是按位判断，2的幂的二进制表示只包含一个1；还有一种方法是在可表达范围找到一个最大的2的幂，判断能不能用这个整数整除。&lt;/p>
&lt;h2 id="reorder-list">Reorder List&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/reorder-list/" target="_blank" rel="noopener"
>Reorder List&lt;/a>题目大意：把链表$L_0 → L_1 → … → L_{n-1} → L_n$重排成$L_0 → L_n → L_1 → L_{n-1} → L_2 → L_{n-2} → …$&lt;/p>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg" >
&lt;img src="https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg"
loading="lazy"
alt="Reorder List">
&lt;/a>
&lt;figcaption>Reorder List&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>链表只能单向遍历，借助栈这种后进先出的数据结构可以比较简单地实现这种重排。&lt;/p>
&lt;h2 id="course-schedule-ii">Course Schedule II&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/course-schedule-ii/" target="_blank" rel="noopener"
>Course Schedule II&lt;/a>题目大意：已知一些课程和先修课程要求——指在学习课程A之前必须先学习课程B，求学完全部课程的顺序，如果没有一种合理的顺序就返回空。&lt;/p>
&lt;p>Course Schedule是一系列题，因为最近时间紧张我没有做完这个系列的全部题，这里只记录这道题的解法，整个系列的以后补上。&lt;/p>
&lt;p>这道题可以用图的思路去解答，把所有课程看作是有向图中的结点，如果学习课程A之前必须先学习B，那么就在图上添加一条B指向A的边。在初始状态下只有没有入度的课程可以学习，表示这些课程没有先修课程。维护所有课程的入度，将所有入度为0的课程都加入一个队列中，表示它们可以学习。依次学习队列中的课程，把课程添加到解中，并把该课程指向的课程入度减1，如果指向的课程入度为0，就添加到学习队列。直到学习队列为空，说明已经没有可以学习的课程了，此时判断解中是否包含全部课程，如果是就返回解，如果不是就说明还有其他课程无法学习，返回空。&lt;/p>
&lt;h2 id="merge-intervals">Merge Intervals&lt;/h2>
&lt;p>虽然是一道中等难度的题，但是不难，略。&lt;/p>
&lt;h2 id="basic-calculator-ii">Basic Calculator II&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/basic-calculator-ii/" target="_blank" rel="noopener"
>Basic Calculator II&lt;/a>题目大意：已知一个由数字和四则运算符号组成的表达式字符串，计算这个表达式的值。&lt;/p>
&lt;p>计算表达式的值没有太多可以说的点，通常的做法是用两个栈，一个保存运算数，一个保存运算符，每次计算的时候弹出两个数和一个符号，算出结果之后再压栈。这道题主要需要注意的地方就是运算优先级，在一个没有括号的表达式里乘除法的优先级高于加减法，所以遇到乘除号可以直接计算。这样就保证运算符栈内只有加减法，加减法需要按顺序计算，做法是每当运算符栈内有两个运算符，就计算栈底的运算符。这时候弹出3个运算数，2个运算符，计算完成后压入2个运算数和1个运算符。&lt;/p>
&lt;h2 id="k-closest-points-to-origin">K Closest Points to Origin&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/k-closest-points-to-origin/" target="_blank" rel="noopener"
>K Closest Points to Origin&lt;/a>题目大意：已知若干二维平面点的坐标，求距离原点最近的k个点的坐标。&lt;/p>
&lt;p>感觉考察点应该是结构体的排序？中等难度但是做起来很简单，排序或者用优先队列都可以。&lt;/p></description></item><item><title>LeetCode每日一题周总结(七)</title><link>https://zhangleijuly.me/p/leetcode-weekly-7/</link><pubDate>Fri, 17 Dec 2021 00:00:00 +0000</pubDate><guid>https://zhangleijuly.me/p/leetcode-weekly-7/</guid><description>&lt;img src="https://zhangleijuly.me/img/LeetCode.jpeg" alt="Featured image of post LeetCode每日一题周总结(七)" />&lt;h2 id="consecutive-characters">Consecutive Characters&lt;/h2>
&lt;p>太简单了，略。&lt;/p>
&lt;h2 id="range-sum-of-bst">Range Sum of BST&lt;/h2>
&lt;p>也略。&lt;/p>
&lt;h2 id="insertion-sort-list">Insertion Sort List&lt;/h2>
&lt;p>链表版的插入排序，收获的经验是解决链表问题创建一个&lt;code>dummy&lt;/code>节点有时候非常好用。&lt;/p>
&lt;h2 id="minimum-height-trees">Minimum Height Trees&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/minimum-height-trees/" target="_blank" rel="noopener"
>Minimum Height Trees&lt;/a>题目大意：已知n个结点和n-1条边，以任何一个结点作为树根可以得到一棵树，求构成的树的高度最低的结点。&lt;/p>
&lt;p>这道题看起来是一道树的题目，但是实际上它是一道图的题目。把这棵树看作一个图，那么构成树的高度最低就意味着这个结点最接近图的“中心”。从这种角度理解这道题的解法应该是从外层一层一层剥离结点，直到剩下1个或者2个结点（如果剩下2个结点，就无法继续剥离了；如果剩下3个结点，因为树中无环，那么一定还能剥离2个结点得到1个结点）。&lt;/p>
&lt;p>首先需要求最外层的结点，也就是叶结点，叶结点只和一个结点相邻。遍历所有边，记录每个结点的相邻关系。然后遍历所有结点，找到所有只和一个结点相邻的结点，存入队列。&lt;/p>
&lt;p>用一个循环来层层剥离，每次执行循环体剥离一层叶结点，记录未被剥离的结点数作为循环终止条件。首先把未剥离的结点数减少当前叶结点数。接下来剥离这层叶结点，遍历当前叶节点队列，把叶节点从它的相邻结点的相邻关系里删除。如果叶节点的相邻结点成为了新的叶节点，就把它保存到一个临时队列。遍历完所有当前叶节点后，用临时队列替换当前叶节点队列。&lt;/p>
&lt;p>最后叶结点队列中剩余的1个或者2个结点即为所求。&lt;/p>
&lt;h2 id="maximal-square">Maximal Square&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/maximal-square/" target="_blank" rel="noopener"
>Maximal Square&lt;/a>题目大意：已知一个由0和1构成的m×n大小的矩阵，找到由1构成的最大的正方形，返回它的面积。&lt;/p>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg" >
&lt;img src="https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg"
loading="lazy"
alt="Maximal Square">
&lt;/a>
&lt;figcaption>Maximal Square&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>之前做过一道&lt;a class="link" href="https://zhangleijuly.me/p/leetcode-weekly-5/#maximal-rectangle" >Maximal Rectangle&lt;/a>，这道题稍微简单点。用&lt;code>dp[i][j]&lt;/code>表示右下角坐标为&lt;code>(i,j)&lt;/code>的正方形的边长，那么当&lt;code>matrix[i][j]==0&lt;/code>时，&lt;code>dp[i][j]=0&lt;/code>；当&lt;code>matrix[i][j]==1&lt;/code>时，&lt;code>dp[i][j]=min(dp[i-1][j-1],dp[i][j-1],dp[i-1][j])+1&lt;/code>。找到最大的边长就能找到答案。&lt;/p>
&lt;h2 id="numbers-at-most-n-given-digit-set">Numbers At Most N Given Digit Set&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/numbers-at-most-n-given-digit-set/" target="_blank" rel="noopener"
>Numbers At Most N Given Digit Set&lt;/a>题目大意：已知一个数字集合和一个整数n，数字集合中包含1~9的几个数字，求用这些数字构成的不大于n的整数有多少个。&lt;/p>
&lt;p>这道题其实是一道排列组合题，需要用代码实现数学计算的过程，需要注意一些细节。&lt;/p>
&lt;p>比n小的数包括位数比n少的数，这些数可以随意组合，比较容易计算。主要需要考虑和n位数相等的数，需要从高位到低位遍历，如果这一位的数在数字集合里没有，那么这一位我们只能选比它小的数，后面的每一位都可以随意选择，跳出循环；如果这一位在数字集合里有，那么要分为两种情况，一种是选择比它小的数，后面每一位可以随意选择，另一种是选择这个数，继续遍历。需要注意的是，如果遍历到最低位每一个数都在集合中出现过，那么还需要在结果加1，也就是这个数本身。&lt;/p>
&lt;h2 id="decode-string">Decode String&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/decode-string/" target="_blank" rel="noopener"
>Decode String&lt;/a>题目大意：解码字符串，字符串编码形如&lt;code>k[encoded_string]&lt;/code>，表示方括号中的字符串出现k次，需要注意方括号中的字符串可能也需要解码。&lt;/p>
&lt;p>递归处理即可，从头到尾读取字符串，没有遇到数字就一直读取，遇到数字就解析数字，获取重复次数，然后截取'[&amp;lsquo;和&amp;rsquo;]&amp;lsquo;之间的字符串，递归调用该函数得到解码结果，把解码结果按照次数重复，然后继续读取字符串解码直到结束。&lt;/p></description></item><item><title>LeetCode每日一题周总结(六)</title><link>https://zhangleijuly.me/p/leetcode-weekly-6/</link><pubDate>Mon, 13 Dec 2021 00:00:00 +0000</pubDate><guid>https://zhangleijuly.me/p/leetcode-weekly-6/</guid><description>&lt;img src="https://zhangleijuly.me/img/LeetCode.jpeg" alt="Featured image of post LeetCode每日一题周总结(六)" />&lt;h2 id="minimum-cost-to-move-chips-to-the-same-position">Minimum Cost to Move Chips to The Same Position&lt;/h2>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2020/08/15/chips_e1.jpg" >
&lt;img src="https://assets.leetcode.com/uploads/2020/08/15/chips_e1.jpg"
loading="lazy"
alt="Minimum Cost to Move Chips to The Same Position">
&lt;/a>
&lt;figcaption>Minimum Cost to Move Chips to The Same Position&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/minimum-cost-to-move-chips-to-the-same-position/" target="_blank" rel="noopener"
>Minimum Cost to Move Chips to The Same Position&lt;/a>题目大意：有n摞筹码，每个筹码可以以如下的方式移动：&lt;/p>
&lt;ul>
&lt;li>以代价0向左或者向右移动2格&lt;/li>
&lt;li>以代价1向左或者向右移动1格&lt;/li>
&lt;/ul>
&lt;p>求把所有筹码摞成一摞的最小代价。&lt;/p>
&lt;p>根据题意，所有奇数位置的筹码可以无代价移动到奇数位置，偶数位置的筹码可以无代价移动到偶数位置，在奇数位置和偶数位置之间移动才需要代价，所以只需要统计奇数位置和偶数位置的筹码数量哪种比较多。&lt;/p>
&lt;h2 id="convert-binary-number-in-a-linked-list-to-integer">Convert Binary Number in a Linked List to Integer&lt;/h2>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2019/12/05/graph-1.png" >
&lt;img src="https://assets.leetcode.com/uploads/2019/12/05/graph-1.png"
loading="lazy"
alt="Convert Binary Number in a Linked List to Integer">
&lt;/a>
&lt;figcaption>Convert Binary Number in a Linked List to Integer&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/" target="_blank" rel="noopener"
>Convert Binary Number in a Linked List to Integer&lt;/a>题目大意：一个链表只包含0和1，把这个链表看作一个二进制数，求这个数的十进制表示。&lt;/p>
&lt;p>略。&lt;/p>
&lt;h2 id="binary-tree-tilt">Binary Tree Tilt&lt;/h2>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2020/10/20/tilt1.jpg" >
&lt;img src="https://assets.leetcode.com/uploads/2020/10/20/tilt1.jpg"
loading="lazy"
alt="Binary Tree Tilt">
&lt;/a>
&lt;figcaption>Binary Tree Tilt&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/binary-tree-tilt/" target="_blank" rel="noopener"
>Binary Tree Tilt&lt;/a>题目大意：求二叉树每个节点坡度之和。二叉树节点的坡度是该节点左子树节点之和与右子树节点之和的差的绝对值。&lt;/p>
&lt;p>略。&lt;/p>
&lt;h2 id="jump-game-iii">Jump Game III&lt;/h2>
&lt;p>一个系列题目，一共有7道题，每道题之间的解法也不太一样。&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/jump-game/" target="_blank" rel="noopener"
>Jump Game&lt;/a>题目大意：已知一个数组&lt;code>nums&lt;/code>，初始在第一个位置，每个位置的数字表示从这个位置最多可以跳多远，如果能到达最后一个位置，返回&lt;code>true&lt;/code>，否则返回&lt;code>false&lt;/code>。&lt;/p>
&lt;p>模拟题，用&lt;code>range&lt;/code>表示可抵达的范围，那么最初&lt;code>range=0&lt;/code>。从0开始遍历所有下标小于等于&lt;code>range&lt;/code>的位置，如果可以到达更远的位置就更新&lt;code>range&lt;/code>，最后判断&lt;code>range&lt;/code>是否包含最后一个位置。&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/jump-game-ii/" target="_blank" rel="noopener"
>Jump Game II&lt;/a>题目大意：已知一个数组&lt;code>nums&lt;/code>，初始在第一个位置，每个位置的数字表示从这个位置最多可以跳多远，求最少需要多少步可以跳到最后一个位置。题目保证可以跳到最后一个位置。&lt;/p>
&lt;p>还是模拟，一步一步跳，每一个位置都有一个可以抵达的范围，在这个范围内找到跳得最远的位置作为下一步的落脚点，直到能够到达最后一个位置。&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/jump-game-iii/" target="_blank" rel="noopener"
>Jump Game III&lt;/a>题目大意：已知一个数组&lt;code>nums&lt;/code>，初始在位置&lt;code>start&lt;/code>，每次从下标&lt;code>i&lt;/code>可以跳到下标&lt;code>i-nums[i]&lt;/code>或者&lt;code>i+nums[i]&lt;/code>，求能不能从起始位置跳到一个值为0的位置。&lt;/p>
&lt;p>按照题意进行深度优先搜索。&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/jump-game-iv/" target="_blank" rel="noopener"
>Jump Game IV&lt;/a>题目大意：已知一个数组&lt;code>arr&lt;/code>，初始在第一个位置，每次可以从下标&lt;code>i&lt;/code>按照如下规则跳跃：&lt;/p>
&lt;ul>
&lt;li>当&lt;code>i+1&amp;lt;arr.length&lt;/code>时跳到&lt;code>i+1&lt;/code>&lt;/li>
&lt;li>当&lt;code>i-1&amp;gt;=0&lt;/code>时跳到&lt;code>i-1&lt;/code>&lt;/li>
&lt;li>当&lt;code>arr[i]==arr[j]&lt;/code>并且&lt;code>i!=j&lt;/code>时跳到&lt;code>j&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>求最少多少步可以跳到最后一个位置。&lt;/p>
&lt;p>需要定义几个数组，&lt;code>step[i]&lt;/code>表示到下标&lt;code>i&lt;/code>最少需要的步数，&lt;code>visited[i]&lt;/code>表示是否到达过下标&lt;code>i&lt;/code>。建立一个队列，每次找到能够到达的新的点就加入队列，这样可以保证队列里的下是按照到达步数递增排列的。建立一个&lt;code>hash&lt;/code>表，对于数组中的每一个值，都记录数组里这个值的所有下标。&lt;/p>
&lt;p>初始化&lt;code>step[0]=0,visited[0]=true&lt;/code>，把0加入队列。循环遍历队列，从队列中取出第一个元素&lt;code>x&lt;/code>，如果这个元素是最后一个位置就跳出循环。否则先判断&lt;code>x-1&lt;/code>是否访问过，如果没有访问过，更新&lt;code>step[x-1]=step[x]+1,visited[x-1]=true&lt;/code>，把&lt;code>x-1&lt;/code>加入队列。然后对&lt;code>x+1&lt;/code>做类似操作。接下来遍历&lt;code>hash[arr[x]]&lt;/code>中的所有下标，更新其中未被访问过的下标的&lt;code>step&lt;/code>和&lt;code>visited&lt;/code>数组，并加入队列。遍历完成后清空&lt;code>hash[arr[x]]&lt;/code>。（&lt;strong>注意&lt;/strong>：一定要清空，这是为了避免重复遍历，我就是因为没有清空所有个别样例一直超时。）循环结束后&lt;code>step[arr.length-1]&lt;/code>即为所求。&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/jump-game-v/" target="_blank" rel="noopener"
>Jump Game V&lt;/a>题目大意：已知一个数组&lt;code>arr&lt;/code>和一个整数&lt;code>d&lt;/code>，每次可以从下标&lt;code>i&lt;/code>按照如下规则跳跃：&lt;/p>
&lt;ul>
&lt;li>如果&lt;code>i+x&amp;lt;arr.length&lt;/code>并且&lt;code>0&amp;lt;x&amp;lt;=d&lt;/code>，可以跳到&lt;code>i+x&lt;/code>&lt;/li>
&lt;li>如果&lt;code>i-x&amp;gt;=0&lt;/code>并且&lt;code>0&amp;lt;x&amp;lt;=d&lt;/code>，可以跳到&lt;code>i-x&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>并且从&lt;code>i&lt;/code>跳到&lt;code>j&lt;/code>时必须满足&lt;code>arr[i]&amp;gt;arr[j]&lt;/code>和&lt;code>i&lt;/code>与&lt;code>j&lt;/code>之间的所有下标&lt;code>k&lt;/code>都满足&lt;code>arr[i]&amp;gt;arr[k]&lt;/code>。&lt;/p>
&lt;p>可以选择从任何位置开始跳跃，求最多可以访问多少个下标。&lt;/p>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2020/01/23/meta-chart.jpeg" >
&lt;img src="https://assets.leetcode.com/uploads/2020/01/23/meta-chart.jpeg"
loading="lazy"
alt="Jump Game V">
&lt;/a>
&lt;figcaption>Jump Game V&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>通俗地说就是只能从高处向低处跳，最远跳跃距离是&lt;code>d&lt;/code>，并且途经的位置也必须比起点低。用&lt;code>dp[i]&lt;/code>表示以下标为&lt;code>i&lt;/code>的位置为起点最多可以访问多少下标。那么状态转移公式为：&lt;code>dp[i]=max(1,max(dp[j])+1)&lt;/code>，其中&lt;code>j&lt;/code>是从&lt;code>i&lt;/code>可以跳到的下标。为了保证在计算&lt;code>dp[i]&lt;/code>时所有&lt;code>dp[j]&lt;/code>都已经被计算过，应该把所有下标按照高度从低到高排序，然后按照排序计算&lt;code>dp[i]&lt;/code>。最后取所有&lt;code>dp[i]&lt;/code>中最大的。&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/jump-game-vi" target="_blank" rel="noopener"
>Jump Game VI&lt;/a>题目大意：已知一个长度为&lt;code>n&lt;/code>的整型数组&lt;code>nums&lt;/code>和整数&lt;code>k&lt;/code>，起始下标为0，每次可以从下标&lt;code>i&lt;/code>跳跃到区间&lt;code>[i+1,min(n-1,i+k)]&lt;/code>中的任意下标。当跳跃到数组的最后一个下标也就是&lt;code>n-1&lt;/code>的时候，你的得分是途中经过的每个下标处值之和，求可能得到的最大得分。&lt;/p>
&lt;p>用&lt;code>dp[i]&lt;/code>表示在跳跃到下标&lt;code>i&lt;/code>处时可以获得的最大得分，那么&lt;code>dp[i]=max(dp[j])+nums[i]&lt;/code>，其中&lt;code>j&lt;/code>是可以跳到&lt;code>i&lt;/code>的下标。因为这道题的数据规模很大，$1 &amp;lt;= k &amp;lt;= 10^5$，所以需要一个能快速找到最大的&lt;code>dp[j]&lt;/code>的方法。&lt;/p>
&lt;p>维护一个最大优先队列，把所有计算过的&lt;code>dp[j]&lt;/code>都放进去，计算&lt;code>dp[i]&lt;/code>的时候就从队列头部取&lt;code>dp[j]&lt;/code>，如果&lt;code>j&lt;/code>不能跳到&lt;code>i&lt;/code>就弹出，直到&lt;code>j&lt;/code>能够跳到&lt;code>i&lt;/code>，用&lt;code>dp[j]&lt;/code>更新&lt;code>dp[i]&lt;/code>。最后&lt;code>dp[n-1]&lt;/code>即为所求。&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/jump-game-vii/" target="_blank" rel="noopener"
>Jump Game VII&lt;/a>题目大意：已知一个字符串&lt;code>s&lt;/code>和两个整数&lt;code>minJump&lt;/code>和&lt;code>maxJump&lt;/code>。起始下标为0，对应字符也是&lt;code>'0'&lt;/code>。符合以下条件时可以从下标&lt;code>i&lt;/code>跳跃到下标&lt;code>j&lt;/code>：&lt;/p>
&lt;ul>
&lt;li>&lt;code>i+minJump &amp;lt;= j &amp;lt;= min(i+maxJump, s.length-1)&lt;/code>&lt;/li>
&lt;li>&lt;code>s[j]=='0'&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>如果能跳跃到数组最后一个位置，返回&lt;code>true&lt;/code>，否则返回&lt;code>false&lt;/code>。&lt;/p>
&lt;p>首先如果&lt;code>s[s.length-1]&lt;/code>不是&lt;code>'0'&lt;/code>可以直接返回&lt;code>false&lt;/code>。其他情况我们就需要判断是不是真的能跳跃到最后一个下标。&lt;/p>
&lt;p>每次从下标&lt;code>i&lt;/code>可以跳跃到的范围是&lt;code>[i+minJump, min(i+maxJump, s.length-1)]&lt;/code>，如果最后一个下标在这个范围内就可以返回&lt;code>true&lt;/code>，否则我们需要记录这个范围内所有&lt;code>s[j]=='0'&lt;/code>的下标&lt;code>j&lt;/code>用于后续的跳跃。&lt;/p>
&lt;p>用一个队列维护起跳位置，初始只有0，同时记录已经处理过的最大跳跃范围&lt;code>range&lt;/code>。每次从队首弹出一个起跳位置&lt;code>i&lt;/code>，那么从&lt;code>i&lt;/code>跳跃范围的左边界&lt;code>l=i+minJump&lt;/code>，右边界&lt;code>r=min(i+maxJump,s.length-1)&lt;/code>。如果左边界&lt;code>l&amp;gt;s.length-1&lt;/code>，那么返回&lt;code>false&lt;/code>，因为从后续的位置只会跳得比&lt;code>i&lt;/code>远，范围也不会包含最后一个下标。如果&lt;code>s.length-1&lt;/code>在左右边界之间，返回&lt;code>true&lt;/code>。都不是就说明还需要继续跳跃，首先更新&lt;code>l=max(l,range+1)&lt;/code>，这是为了避免重复处理，只处理没有处理过的下标。把&lt;code>l&lt;/code>和&lt;code>r&lt;/code>之间所有为&lt;code>'0'&lt;/code>的下标都加入队列，更新&lt;code>range=r&lt;/code>。如果循环结束都没有返回，就说明跳得不够远，返回&lt;code>false&lt;/code>。&lt;/p>
&lt;h2 id="domino-and-tromino-tiling">Domino and Tromino Tiling&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/domino-and-tromino-tiling/" target="_blank" rel="noopener"
>Domino and Tromino Tiling&lt;/a>题目大意：求下面两种形状拼成2×n的形状有多少种方法。&lt;/p>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2021/07/15/lc-domino.jpg" >
&lt;img src="https://assets.leetcode.com/uploads/2021/07/15/lc-domino.jpg"
loading="lazy"
alt="Domino and Tromino Tiling">
&lt;/a>
&lt;figcaption>Domino and Tromino Tiling&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>例如拼成2×5的形状有以下方法：&lt;/p>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2021/07/15/lc-domino1.jpg" >
&lt;img src="https://assets.leetcode.com/uploads/2021/07/15/lc-domino1.jpg"
loading="lazy"
alt="2×5">
&lt;/a>
&lt;figcaption>2×5&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>这道题是真的没想明白，直接看&lt;a class="link" href="https://leetcode.com/problems/domino-and-tromino-tiling/discuss/116581/Detail-and-explanation-of-O%28n%29-solution-why-dpn2*dn-1&amp;#43;dpn-3" target="_blank" rel="noopener"
>大神推导的递推公式&lt;/a>吧。看到下面的评论“高中一眼看出来的公式，现在一开始以为是魔法。”真的泪目了。&lt;/p>
&lt;h2 id="nth-magical-number">Nth Magical Number&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/nth-magical-number/" target="_blank" rel="noopener"
>Nth Magical Number&lt;/a>题目大意：如果一个正整数能整除a或者b就称为魔数。已知n，a和b，求第n个魔数。&lt;/p>
&lt;p>魔数是有一个周期的，也就是a和b的最小公倍数lcm。任何魔数加上最小公倍数的整数倍还是魔数。一个周期内的魔数有$N = lcm/a + lcm/b -1$个。那么第n个魔数就是lcm的$\lfloor n/N \rfloor$倍加上第$n\bmod N$个魔数。前者容易计算，后者可以把lcm以内所有a和b的倍数放到一个数组中排序求得。&lt;/p>
&lt;p>还有&lt;a class="link" href="https://leetcode.com/problems/nth-magical-number/discuss/154965/o%20%281%29-Mathematical-Solution-without-binary-or-brute-force-search" target="_blank" rel="noopener"
>一种纯数学方法&lt;/a>是利用魔数的分布去逼近，然后求出准确值。我专门和数院的同学讨论了一下这种方法为什么能准确地求出第x个魔数，因为它通过近似找到了不小于第x个魔数的a的倍数和b的倍数，这两个数就是第x个和第x+1个魔数。&lt;/p>
&lt;h2 id="partition-equal-subset-sum">Partition Equal Subset Sum&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener"
>Partition Equal Subset Sum&lt;/a>题目大意：已知一个由正整数构成的非空集合，求能不能把它分成两个集合，这两个集合中数字的和相等。&lt;/p>
&lt;p>这道题思路很简单，首先把集合中所有数字加起来，如果和是奇数那么肯定不可能，如果是偶数那么题目变成能不能在集合中找到一些整数加起来等于和的一半。&lt;/p>
&lt;p>能够想到用动态规划来解，用&lt;code>dp[i][j]&lt;/code>表示用&lt;code>nums[0]&lt;/code>到&lt;code>nums[i]&lt;/code>的集合能否找到和为&lt;code>j&lt;/code>的子集。那么状态转移条件是，当选择&lt;code>nums[i]&lt;/code>加入子集时，如果&lt;code>dp[i-1][j-nums[i]]==true&lt;/code>，那么&lt;code>dp[i][j]=true&lt;/code>。当不选择&lt;code>nums[i]&lt;/code>加入子集时，如果&lt;code>dp[i][j]==true&lt;/code>，那么&lt;code>dp[i][j]=true&lt;/code>。&lt;/p>
&lt;p>可以进行状态压缩，用&lt;code>dp[j]&lt;/code>表示能否找到和为&lt;code>j&lt;/code>的子集。遍历整个数组，对于每个下标&lt;code>i&lt;/code>，从和的一半开始遍历&lt;code>j&lt;/code>到&lt;code>nums[i]&lt;/code>，如果&lt;code>dp[j-nums[i]]==true&lt;/code>，那么&lt;code>dp[j]=true&lt;/code>。&lt;/p></description></item><item><title>LeetCode每日一题周总结(五)</title><link>https://zhangleijuly.me/p/leetcode-weekly-5/</link><pubDate>Sun, 05 Dec 2021 00:00:00 +0000</pubDate><guid>https://zhangleijuly.me/p/leetcode-weekly-5/</guid><description>&lt;img src="https://zhangleijuly.me/img/LeetCode.jpeg" alt="Featured image of post LeetCode每日一题周总结(五)" />&lt;h2 id="accounts-merge">Accounts Merge&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/accounts-merge/" target="_blank" rel="noopener"
>Accounts Merge&lt;/a>题目大意：有很多组账户信息，账户信息包括用户的名字和该用户所拥有的一个或者多个邮箱。如果两个用户拥有同一个邮箱，就说明这两个用户是同一个人。两个用户的名字相同但是不拥有同一个邮箱则认为他们是名字相同的不同用户。把所有用户相同的账户信息合并，按照题目规定的格式输出。&lt;/p>
&lt;p>用并查集解决，每个账户信息可以看作一个集合，如果两个集合中有公共的邮箱地址就合并。用一个hash表保存邮箱和集合之间的映射关系，方便快速找到出现相同邮箱的集合。&lt;/p>
&lt;h2 id="maximal-rectangle">Maximal Rectangle&lt;/h2>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg" >
&lt;img src="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg"
loading="lazy"
alt="Maximal Rectangle">
&lt;/a>
&lt;figcaption>Maximal Rectangle&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/maximal-rectangle/" target="_blank" rel="noopener"
>Maximal Rectangle&lt;/a>题目大意：在由0和1构成的矩形中，找到最大的只由1构成的矩形，输出它的面积。&lt;/p>
&lt;p>容易想到用动态规划解决，但是方法不太容易想。用&lt;code>dp[i][j]&lt;/code>表示第&lt;code>i&lt;/code>行第&lt;code>j&lt;/code>列之前共有多少个连续的1。状态转移关系如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">matrix&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">else&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">else&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>遍历所有的坐标&lt;code>(i,j)&lt;/code>，遍历所有在&lt;code>[i,matrix.size())&lt;/code>之间的&lt;code>k&lt;/code>，计算右上为&lt;code>(i,j)&lt;/code>右下为&lt;code>(k,j)&lt;/code>的最大矩形面积并更新答案。这样的矩形一边长度为&lt;code>(k-i+1)&lt;/code>，另一边的长度为从&lt;code>i&lt;/code>到&lt;code>k&lt;/code>所有&lt;code>dp[i][j]&lt;/code>的最小值。&lt;/p>
&lt;h2 id="house-robber">House Robber&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener"
>House Robber&lt;/a>题目大意：你是一个专业的抢劫犯准备沿着一条街抢劫，已知一个数组表示这条街上每一家可以抢劫到的钱数。如果街上相邻两家被抢就会自动报警，求在不触发警报的情况下最多可以抢到多少钱。&lt;/p>
&lt;p>一道动态规划的题目。用&lt;code>dp[i]&lt;/code>表示抢劫第&lt;code>i&lt;/code>家时最多可以抢到多少钱，状态转移关系如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>至少可以保证抢到第&lt;code>i&lt;/code>家的钱，如果&lt;code>i&lt;/code>足够大，在不触发警报的情况下考虑前面的抢劫，只有两种情况，上一次抢劫的是第&lt;code>i-2&lt;/code>家或者是第&lt;code>i-3&lt;/code>家。在这几种情况中选择钱最多的更新&lt;code>dp[i]&lt;/code>，并用&lt;code>dp[i]&lt;/code>更新答案。&lt;/p>
&lt;h2 id="odd-even-linked-list">Odd Even Linked List&lt;/h2>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg" >
&lt;img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg"
loading="lazy"
alt="Odd Even Linked List">
&lt;/a>
&lt;figcaption>Odd Even Linked List&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/odd-even-linked-list/" target="_blank" rel="noopener"
>Odd Even Linked List&lt;/a>题目大意：把链表中的奇数结点和偶数结点各自组织成一个链表并连接。&lt;/p>
&lt;p>考察基本的链表操作，定义奇链表和偶链表，遍历初始链表，按照奇偶把结点加入这两个链表中，最后把偶链表连接在奇链表后面。&lt;/p>
&lt;h2 id="maximum-product-subarray">Maximum Product Subarray&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank" rel="noopener"
>Maximum Product Subarray&lt;/a>题目大意：求一个数组的乘积最大的子数组，返回乘积的值。子数组是指数组中连续的一部分。&lt;/p>
&lt;p>之前做过的&lt;a class="link" href="https://zhangleijuly.me/p/leetcode-weekly-4/#maximum-subarray" >Maximum Subarray&lt;/a>是求和最大的子数组，这道题和它类似，区别在于最大乘积存在负负得正的情况，因此不能简单维护一个数组。维护两个数组&lt;code>pos[i]&lt;/code>和&lt;code>neg[i]&lt;/code>，分别表示以&lt;code>i&lt;/code>为结尾的子数组乘积的最大值和最小值。状态转移关系取决于&lt;code>nums[i]&lt;/code>的正负：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">pos&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">pos&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="n">neg&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">min&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">neg&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">else&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">pos&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">neg&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="n">neg&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">min&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">pos&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最大的&lt;code>pos[i]&lt;/code>就是答案。&lt;/p>
&lt;h2 id="stream-of-characters">Stream of Characters&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/stream-of-characters/" target="_blank" rel="noopener"
>Stream of Characters&lt;/a>题目大意：已知一个字典，实现一个类，该类每次从字符流中读取一个字符并能够判断字符流的后缀是否出现了字典中的单词。&lt;/p>
&lt;p>这道题用到的数据结构是&lt;a class="link" href="https://oi-wiki.org/string/trie/" target="_blank" rel="noopener"
>Trie树&lt;/a>，也叫做字典树，同样是之前听说过但是没有用过的。这种数据类型能够把字典储存在一棵树中，最基本的应用是查找一个字符串是否在字典中出现。在这道题中是查找字符串的后缀是否在字典中出现。&lt;/p>
&lt;p>&lt;figure
>
&lt;a href="https://oi-wiki.org/string/images/trie1.png" >
&lt;img src="https://oi-wiki.org/string/images/trie1.png"
loading="lazy"
alt="Trie树">
&lt;/a>
&lt;figcaption>Trie树&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>通常来说字典树可以用来查找字符串的前缀是否在字典中出现，要查找字符串的后缀是否在字典中出现就需要倒序建树并且倒序查找。&lt;/p>
&lt;h2 id="house-robber-iii">House Robber III&lt;/h2>
&lt;p>House Robber系列题型，一共包含三道题。&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener"
>House Robber&lt;/a>上面已经讲过，就不再赘述。&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/house-robber-ii/" target="_blank" rel="noopener"
>House Robber II&lt;/a>题目大意：条件和第一题相同，区别在于街道变成了首尾相连。&lt;/p>
&lt;p>这道题在第一题算法的基础上修改一下就可以，我把情况分成了抢劫第一家和不抢劫第一家，想了很久都没有做出来。实际上首尾相连之后第一家和最后一家不能被同时抢劫了，在数组中分别删除第一项和删除最后一项，用第一题的算法各算一遍取最大的结果即可。&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/house-robber-iii/" target="_blank" rel="noopener"
>House Robber III&lt;/a>题目大意：这道题住宅区从线性变成了树形，劫匪要抢劫形如二叉树的区域，如果抢劫直接相连的两家就会触发警报，求在不触发警报的情况下最多可以抢劫到多少钱。&lt;/p>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg" >
&lt;img src="https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg"
loading="lazy"
alt="House Robber III">
&lt;/a>
&lt;figcaption>House Robber III&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>还是用动态规划，递归地为每个结点计算两个数值&lt;code>rob&lt;/code>和&lt;code>notRob&lt;/code>，分别表示在当前结点抢劫和不抢劫所能获得的最大金钱。如果结点为空，那么这两个数值都为0。如果结点不为空，那么当前结点的状态转移公式如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="n">root&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">notRob&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">notRob&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">rob&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">notRob&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">rob&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">root&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">rob&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">notRob&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">notRob&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">val&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>取根结点的&lt;code>rob&lt;/code>和&lt;code>notRob&lt;/code>的最大值就是答案。&lt;/p></description></item><item><title>LeetCode每日一题周总结(四)</title><link>https://zhangleijuly.me/p/leetcode-weekly-4/</link><pubDate>Sun, 28 Nov 2021 00:00:00 +0000</pubDate><guid>https://zhangleijuly.me/p/leetcode-weekly-4/</guid><description>&lt;img src="https://zhangleijuly.me/img/LeetCode.jpeg" alt="Featured image of post LeetCode每日一题周总结(四)" />&lt;h2 id="delete-node-in-a-bst">Delete Node in a BST&lt;/h2>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" >
&lt;img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg"
loading="lazy"
alt="Delete Node in a BST">
&lt;/a>
&lt;figcaption>Delete Node in a BST&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener"
>Delete Node in a BST&lt;/a>题目大意：删除二叉搜索树的一个节点。&lt;/p>
&lt;p>数据结构与算法的经典问题，分三种情况：&lt;/p>
&lt;ol>
&lt;li>该节点是叶子节点，直接删除；&lt;/li>
&lt;li>该节点只有一个子节点，用子节点代替该节点位置；&lt;/li>
&lt;li>该节点有两个子节点，删除该节点后，为了保持二叉搜索树的性质，应该用左子树的最大值或者右子树的最小值代替该节点。&lt;/li>
&lt;/ol>
&lt;p>可以参考&lt;a class="link" href="https://oi-wiki.org/ds/bst/#_6" target="_blank" rel="noopener"
>OI Wiki&lt;/a>。&lt;/p>
&lt;h2 id="largest-component-size-by-common-factor">Largest Component Size by Common Factor&lt;/h2>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2018/12/01/ex3.png" >
&lt;img src="https://assets.leetcode.com/uploads/2018/12/01/ex3.png"
loading="lazy"
alt="Largest Component Size by Common Factor">
&lt;/a>
&lt;figcaption>Largest Component Size by Common Factor&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/largest-component-size-by-common-factor/" target="_blank" rel="noopener"
>Largest Component Size by Common Factor&lt;/a>题目大意：已知一个由不同正整数构成的数组，按照如下规则构造一个无向图：&lt;/p>
&lt;ul>
&lt;li>数组中的每个数都代表图中的一个顶点；&lt;/li>
&lt;li>如果两个数存在大于1的公约数，则这两个数代表的顶点之间存在一条边。&lt;/li>
&lt;/ul>
&lt;p>求该图的最大连通分支中包含多少个顶点。&lt;/p>
&lt;p>这道题其实不是图论问题，而是集合划分问题，按照不同的连通分支把数组中的数划分为不同的集合，求最大的集合里有多少个数。解决这类问题用到的数据结构是&lt;a class="link" href="https://oi-wiki.org/ds/dsu/" target="_blank" rel="noopener"
>并查集&lt;/a>，并查集能够用来处理一些&lt;strong>互不相交的集合的合并和查询&lt;/strong>的问题。并查集的定义和实现可以参考&lt;a class="link" href="https://oi-wiki.org/ds/dsu/" target="_blank" rel="noopener"
>OI Wiki&lt;/a>。&lt;/p>
&lt;p>首先需要给顶点划分集合，如果两个数存在1以外的公约数就应该把它们所在的集合合并，但是对每个数都去求它和其他所有数有没有公约数包含了很多重复的工作量。不妨换一种思路，如果我们把每个数和它的所有非1约数的集合都合并，那么两个有非1公约数的数就都跟这个公约数在同一个集合里。然后对每个顶点查找它在哪一个集合里，更新集合的大小和答案即可。&lt;/p>
&lt;h2 id="interval-list-intersections">Interval List Intersections&lt;/h2>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2019/01/30/interval1.png" >
&lt;img src="https://assets.leetcode.com/uploads/2019/01/30/interval1.png"
loading="lazy"
alt="Interval List Intersections">
&lt;/a>
&lt;figcaption>Interval List Intersections&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/interval-list-intersections/" target="_blank" rel="noopener"
>Interval List Intersections&lt;/a>题目大意：已知两个数组，其中包含的是&lt;strong>互不相交&lt;/strong>并且&lt;strong>有序&lt;/strong>的闭区间，求这两个数组中区间的交集。&lt;/p>
&lt;p>这道题是贪心法的一个典型应用。对数组A和B分别维护下标&lt;code>i&lt;/code>和&lt;code>j&lt;/code>，&lt;code>i&lt;/code>和&lt;code>j&lt;/code>初始化为0。计算区间&lt;code>A[i]&lt;/code>和&lt;code>B[j]&lt;/code>的交集，交集的左边界是&lt;code>max(A[i][0],B[j][0])&lt;/code>，右边界是&lt;code>min(A[i][1],B[j][1])&lt;/code>，如果左边界大于右边界说明交集为空。然后比较两个区间的右边界，保留右边界较大的区间，将另一个区间的下标加1。如果两个区间的右边界相等，则两个下标都加1。&lt;/p>
&lt;h2 id="maximum-subarray">Maximum Subarray&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener"
>Maximum Subarray&lt;/a>题目大意：求一个数组的和最大的子数组，返回和的值。子数组是指数组中连续的一部分。&lt;/p>
&lt;p>这道题是典型的动态规划问题。用&lt;code>dp[i]&lt;/code>表示以下标&lt;code>i&lt;/code>结尾的子数组的和的最大值，那么有两种可能，一种是&lt;code>nums[i]&lt;/code>自己构成一个子数组，另一种是它和前面的若干数构成一个子数组，这些子数组中和最大的是以下标&lt;code>i-1&lt;/code>结尾的和最大的子数组再加上&lt;code>nums[i]&lt;/code>，所以状态转移公式是&lt;code>dp[i]=max(nums[i],dp[i-1]+nums[i])&lt;/code>。初始条件是&lt;code>dp[0]=nums[0]&lt;/code>。&lt;/p>
&lt;h2 id="search-insert-position">Search Insert Position&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/search-insert-position/" target="_blank" rel="noopener"
>Search Insert Position&lt;/a>题目大意：已知一个包含&lt;strong>各不相同&lt;/strong>的整数的&lt;strong>有序&lt;/strong>数组中和一个目标值，如果能在数组中找到目标值就返回它的下标，如果不能找到就返回它插入数组中并保持数组有序时它的下标。算法时间复杂度应为$O(\log n)$。&lt;/p>
&lt;p>看题意就知道应该用二分法，需要注意最后找不到目标数时应该返回什么下标。&lt;/p>
&lt;h2 id="product-of-array-except-self">Product of Array Except Self&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank" rel="noopener"
>Product of Array Except Self&lt;/a>题目大意：已知一个整型数组&lt;code>nums&lt;/code>，求数组&lt;code>answer&lt;/code>，使得&lt;code>answer[i]&lt;/code>的值是&lt;code>nums&lt;/code>中除&lt;code>nums[i]&lt;/code>以外所有值之积。题目要求算法复杂度为$O(n)$并且不使用除法。&lt;/p>
&lt;p>自然的想法肯定是把所有数相乘然后依次除以每一个数即可，但是因为数组中可能包含0，所以这种方法本来也行不通。换一种思路，用&lt;code>pre[i]&lt;/code>表示下标小于&lt;code>i&lt;/code>的所有数的乘积，用&lt;code>post[i]&lt;/code>表示下标大于&lt;code>i&lt;/code>的所有数的乘积，那么&lt;code>answer[i]=pre[i]*post[i]&lt;/code>，而求&lt;code>pre[i]&lt;/code>和&lt;code>post[i]&lt;/code>也只需要把数组正反各扫描一遍。&lt;/p>
&lt;h2 id="all-paths-from-source-to-target">All Paths From Source to Target&lt;/h2>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg" >
&lt;img src="https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg"
loading="lazy"
alt="All Paths From Source to Target">
&lt;/a>
&lt;figcaption>All Paths From Source to Target&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/all-paths-from-source-to-target/" target="_blank" rel="noopener"
>All Paths From Source to Target&lt;/a>题目大意：已知一个包含n个顶点的有向无环图，求从0号顶点到n-1号顶点的所有路径。&lt;/p>
&lt;p>使用深度优先搜索即可，在搜索时记录路径，只要到达n-1号顶点就把路径加入答案。&lt;/p></description></item><item><title>LeetCode每日一题周总结(三)</title><link>https://zhangleijuly.me/p/leetcode-weekly-3/</link><pubDate>Sun, 21 Nov 2021 00:00:00 +0000</pubDate><guid>https://zhangleijuly.me/p/leetcode-weekly-3/</guid><description>&lt;img src="https://zhangleijuly.me/img/LeetCode.jpeg" alt="Featured image of post LeetCode每日一题周总结(三)" />&lt;h2 id="largest-divisible-subset">Largest Divisible Subset&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/largest-divisible-subset/" target="_blank" rel="noopener"
>Largest Divisible Subset&lt;/a>题目大意：已知一个不同正整数组成的集合&lt;code>nums&lt;/code>，求它的一个最大子集合&lt;code>answer&lt;/code>，&lt;code>answer&lt;/code>中任意两个整数都满足其中一个是另外一个的整数倍。&lt;/p>
&lt;p>这道题和动态规划的经典问题&lt;a class="link" href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener"
>Longest Increasing Subsequence&lt;/a>类似，只是把条件从大小关系变成了整除关系。&lt;/p>
&lt;p>因为只可能较大的数整除较小的数，所以要先把&lt;code>nums&lt;/code>从小到大排序。接下来找到&lt;code>nums&lt;/code>的满足&lt;code>sub[i+1]%sub[i]==0&lt;/code>最大子序列&lt;code>sub&lt;/code>就得到了答案，因为&lt;code>sub&lt;/code>具有其中任意一个整数都能整除&lt;code>sub&lt;/code>中比它小的整数并且被&lt;code>sub&lt;/code>中比它大的整数整除的性质。&lt;/p>
&lt;p>用&lt;code>dp[i]&lt;/code>存储包含&lt;code>nums[i]&lt;/code>的最大子序列&lt;code>sub&lt;/code>的长度，用&lt;code>pred[i]&lt;/code>存储在该子序列中&lt;code>nums[i]&lt;/code>的前驱在&lt;code>nums&lt;/code>中的下标。对所有&lt;code>i&amp;lt;j&lt;/code>，当&lt;code>nums[j]%nums[i]==0 &amp;amp;&amp;amp; dp[i]+1&amp;gt;dp[j]&lt;/code>时更新&lt;code>dp[j]=dp[i]+1; pred[j]=i&lt;/code>。最后根据&lt;code>dp&lt;/code>找到最大的子序列和其中最大的元素，再根据&lt;code>pred&lt;/code>找到所有其他元素。&lt;/p>
&lt;h2 id="kth-smallest-number-in-multiplication-table">Kth Smallest Number in Multiplication Table&lt;/h2>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2021/05/02/multtable1-grid.jpg" >
&lt;img src="https://assets.leetcode.com/uploads/2021/05/02/multtable1-grid.jpg"
loading="lazy"
alt="Kth Smallest Number in Multiplication Table">
&lt;/a>
&lt;figcaption>Kth Smallest Number in Multiplication Table&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/" target="_blank" rel="noopener"
>Kth Smallest Number in Multiplication Table&lt;/a>题目大意：求乘法表里第k小的数。乘法表是一个矩形表格，其中每一格中的数是这一格的行号乘列号。&lt;/p>
&lt;p>又一道题意简单但是数据规模庞大的题。这道题可以使用二分查找来降低时间复杂度，找到乘法表在1~x区间内有至少k个数的最小x即可。&lt;/p>
&lt;p>假设乘法表大小为m×n，初始化二分查找的左边界&lt;code>l=1&lt;/code>，右边界&lt;code>r=m*n&lt;/code>。查找时首先计算中点&lt;code>mid=(l+r)/2&lt;/code>，然后计算乘法表在1到&lt;code>mid&lt;/code>之间有多少数，如果有不少于k个，说明应该缩小区间，&lt;code>r=mid&lt;/code>；如果不足k个，说明应该扩大区间，&lt;code>l=mid+1&lt;/code>。左右边界相等时就找到了要求的x。二分查找算法模板参见&lt;a class="link" href="https://www.acwing.com/blog/content/31/" target="_blank" rel="noopener"
>AcWing&lt;/a>。&lt;/p>
&lt;p>由于乘法表每一行都是行号的倍数，第i行就有&lt;code>min(n, mid/i)&lt;/code>个数在1和&lt;code>mid&lt;/code>之间，遍历每一行就可以知道乘法表中一共有多少数在1和&lt;code>mid&lt;/code>之间。&lt;/p>
&lt;h2 id="unique-paths">Unique Paths&lt;/h2>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" >
&lt;img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png"
loading="lazy"
alt="Unique Paths">
&lt;/a>
&lt;figcaption>Unique Paths&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>这道题在&lt;a class="link" href="https://zhangleijuly.me/p/leetcode-weekly-1/#unique-paths-iii" >LeetCode 每日一题周总结 (一)&lt;/a>中讲到过。&lt;/p>
&lt;h2 id="find-all-numbers-disappeared-in-an-array">Find All Numbers Disappeared in an Array&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener"
>Find All Numbers Disappeared in an Array&lt;/a>题目大意：已知一个数组大小为n，其中包含1到n之间的整数，求1到n之间有哪些整数没有在数组中出现。&lt;/p>
&lt;p>数组大小为n，其中包含的整数也在1到n之间，那么可以把数组中的整数放到对应下标的位置上去，最后遍历数组，对应下标上的数字不正确就表示缺少这个整数。&lt;/p>
&lt;p>思路很简单，但是编码过程中有不少细节。遍历数组到下标&lt;code>i&lt;/code>，&lt;code>nums[i]&lt;/code>对应的下标是&lt;code>nums[i]-1&lt;/code>，首先检查&lt;code>nums[nums[i]-1]&lt;/code>是否和&lt;code>nums[i]&lt;/code>相等，如果相等就说明那个下标已经有对应的数字了，继续遍历；如果不相等就交换&lt;code>nums[i]&lt;/code>和&lt;code>nums[nums[i]-1]&lt;/code>，交换后&lt;code>nums[i]&lt;/code>是原先在&lt;code>nums[nums[i]-1]&lt;/code>处的数字，需要重新判断是否需要交换，这时需要把下标&lt;code>i&lt;/code>减1，确保下次遍历还检查&lt;code>nums[i]&lt;/code>。&lt;/p>
&lt;h2 id="hamming-distance">Hamming Distance&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/hamming-distance/" target="_blank" rel="noopener"
>Hamming Distance&lt;/a>题目大意：求两个整数的汉明距离。两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。&lt;/p>
&lt;p>把两个整数异或，计算结果的二进制表示中有多少位为1即可。&lt;/p>
&lt;h2 id="single-element-in-a-sorted-array">Single Element in a Sorted Array&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/single-element-in-a-sorted-array/" target="_blank" rel="noopener"
>Single Element in a Sorted Array&lt;/a>题目大意：在有序数组中有一个元素只出现一次，其余元素均成对出现，找到这个只出现一次的元素。要求时间复杂度为$O(\log n)$，空间复杂度为$O(1)$。&lt;/p>
&lt;p>如果没有附加条件，这道题可以直接使用&lt;a class="link" href="https://zhangleijuly.me/p/leetcode-weekly-1/#single-number-iii" >Single Number&lt;/a>的方法求解。考虑到附加条件和已知数组有序，应该使用二分查找来求解。&lt;/p>
&lt;p>二分查找的关键是如何判断这个元素在左半边还是在右半边。如果没有这个元素，那么成对元素的下标应该是2n和2n+1，但是这个元素出现后，成对元素的下标就会向后偏移一位。首先确定中点下标&lt;code>mid&lt;/code>，找到和&lt;code>mid&lt;/code>组成(2n,2n+1)对的另一个下标，可以对&lt;code>mid&lt;/code>的奇偶分类讨论，还有一种简单的方法，另一个下标是&lt;code>mid&lt;/code>异或1。然后判断这两个下标对应的元素是否相等，相等就说明要找的元素还没出现，在右半边；不相等就说明要找的元素在左半边。&lt;/p>
&lt;h2 id="construct-binary-tree-from-inorder-and-postorder-traversal">Construct Binary Tree from Inorder and Postorder Traversal&lt;/h2>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" >
&lt;img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg"
loading="lazy"
alt="Construct Binary Tree from Inorder and Postorder Traversal">
&lt;/a>
&lt;figcaption>Construct Binary Tree from Inorder and Postorder Traversal&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener"
>Construct Binary Tree from Inorder and Postorder Traversal&lt;/a>题目大意：已知一棵树的中序遍历和后序遍历，构造出这棵树。题目保证中序遍历和后序遍历的数都唯一出现。上图为用中序遍历[9, 3, 15, 20, 7]和[9, 15, 7, 20, 3]构造的二叉树。&lt;/p>
&lt;p>可以先建立根节点，再递归地构造左子树和右子树。根节点的值是后序遍历的最后一个值，在中序遍历中找到这个值，以它为分界点把中序遍历分成左右两部分，左半边是左子树的中序遍历，右半边是右子树的中序遍历。这样就得到了左右子树的大小，根据左右子树的大小可以从后序遍历中提取出左子树的后序遍历和右子树的后序遍历。用根节点的值建立根节点，递归调用函数，用左子树的中序遍历和后序遍历生成左子树，并赋值给根节点的指针，然后再类似地生成右子树赋值给根节点的指针。最后返回根节点。&lt;/p>
&lt;p>注意边界条件，如果中序遍历和后序遍历为空，返回空指针。&lt;/p></description></item><item><title>LeetCode每日一题周总结(二)</title><link>https://zhangleijuly.me/p/leetcode-weekly-2/</link><pubDate>Sun, 14 Nov 2021 00:00:00 +0000</pubDate><guid>https://zhangleijuly.me/p/leetcode-weekly-2/</guid><description>&lt;img src="https://zhangleijuly.me/img/LeetCode.jpeg" alt="Featured image of post LeetCode每日一题周总结(二)" />&lt;h2 id="unique-binary-search-trees">Unique Binary Search Trees&lt;/h2>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" >
&lt;img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg"
loading="lazy"
alt="Unique Binary Search Trees">
&lt;/a>
&lt;figcaption>Unique Binary Search Trees&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener"
>Unique Binary Search Trees&lt;/a>题目大意：n个结点的二叉搜索树其结点的值分别为1~n，求这样的二叉搜索树有多少种不同的结构。&lt;/p>
&lt;p>刷软考题时遇到过相同问题，可以把该问题转化为规模更小的问题来求解。假设结点数为n时该问题的解为&lt;code>fun(n)&lt;/code>。对于n个结点的二叉搜索树，选择1个结点作为根节点，可以选择1~n，假设我们选择m作为根节点，那么根据二叉搜索树的性质，左子树将包含1~m-1这m-1个结点，右子树将包含m+1~n这n-m个结点，以m作为根结点的二叉搜索树的结构就有&lt;code>fun(m-1)*fun(m-n)&lt;/code>种。根节点的选择有n种，可以得到以下公式：
$$
fun(n) = \sum_{i=1}^n fun(i-1)*fun(n-i)
$$
为了避免重复运算，我们用数组记录结果，初始化&lt;code>fun[0]=1&lt;/code>，然后从小到大依次求解&lt;code>fun[1]&lt;/code>直到&lt;code>fun[n]&lt;/code>即可。&lt;/p>
&lt;h2 id="number-of-valid-words-for-each-puzzle">Number of Valid Words for Each Puzzle&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/number-of-valid-words-for-each-puzzle/" target="_blank" rel="noopener"
>Number of Valid Words for Each Puzzle&lt;/a>题目大意：输入包括&lt;code>word&lt;/code>和&lt;code>puzzle&lt;/code>两种字符串，对于一个&lt;code>puzzle&lt;/code>，满足以下条件的&lt;code>word&lt;/code>是合法的：&lt;/p>
&lt;ul>
&lt;li>&lt;code>word&lt;/code>包含&lt;code>puzzle&lt;/code>的首字母&lt;/li>
&lt;li>&lt;code>word&lt;/code>中的每一个字母都在&lt;code>puzzle&lt;/code>中出现&lt;/li>
&lt;/ul>
&lt;p>求每个&lt;code>puzzle&lt;/code>分别有多少个合法的&lt;code>word&lt;/code>。&lt;/p>
&lt;p>这道题题意比较简单，数据规模不大的情况下可以直接求解。但是LeetCode给出的数据规模是$1 \leq words.length \leq 10^5$和$1 \leq puzzle.length \leq 10^4$，直接求解一定会超时。&lt;/p>
&lt;p>题目的约束中，&lt;code>word&lt;/code>和&lt;code>puzzle&lt;/code>只包含英文小写字母。用1位二进制表示某个字母在字符串中是否出现，1表示出现，0表示未出现，只需要26位二进制整数就能表示一个字符串包含的字母集合。遍历&lt;code>word&lt;/code>数组，可以求出每一个单词所包含的字母集合，因为不同的单词可能有相同的字母集合，用一个&lt;code>hashMap&lt;/code>保存每一个字母集合分别构成了多少个单词。&lt;/p>
&lt;p>处理完&lt;code>word&lt;/code>之后，对每个&lt;code>puzzle&lt;/code>也计算出表示它所包含字母集合的整数，因为后面用到&lt;a class="link" href="https://zh.wikipedia.org/wiki/%E6%8E%A9%E7%A0%81" target="_blank" rel="noopener"
>&lt;strong>掩码&lt;/strong>&lt;/a>操作，就用&lt;code>mask&lt;/code>表示这个整数。然后需要找到符合条件的&lt;code>mask&lt;/code>集合的子集&lt;code>subMask&lt;/code>。&lt;/p>
&lt;p>首先&lt;code>subMask&lt;/code>一定小于等于&lt;code>mask&lt;/code>，但是并非所有小于等于&lt;code>mask&lt;/code>的整数都是&lt;code>mask&lt;/code>的子集，这时就需要用到&lt;a class="link" href="https://zh.wikipedia.org/wiki/%E6%8E%A9%E7%A0%81" target="_blank" rel="noopener"
>&lt;strong>掩码&lt;/strong>&lt;/a>操作，对任意&lt;code>subMask&lt;/code>，&lt;code>subMask&amp;amp;mask&lt;/code>一定是&lt;code>mask&lt;/code>的子集。用下面的循环就可以遍历所有&lt;code>mask&lt;/code>的子集，掩码操作也是对这个循环的剪枝，大大减少了循环的时间代价。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="kt">int&lt;/span> &lt;span class="n">subMask&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mask&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">subMask&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="c1">//do something
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">subMask&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="n">subMask&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">mask&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然，不要忘记在&lt;code>subMask&lt;/code>中必须包含&lt;code>puzzle&lt;/code>的首字母。对符合条件的&lt;code>subMask&lt;/code>，在&lt;code>hashMap&lt;/code>中查找有多少由该字母集合构成的单词，计入结果中即可。&lt;/p>
&lt;h2 id="best-time-to-buy-and-sell-stock-ii">Best Time to Buy and Sell Stock II&lt;/h2>
&lt;p>这周最有意思的有一道题，兄弟姐妹也真的多，同系列一共有6道题，包括&lt;a class="link" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener"
>Best Time to Buy and Sell Stock&lt;/a>、&lt;a class="link" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener"
>Best Time to Buy and Sell Stock II&lt;/a>、&lt;a class="link" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener"
>Best Time to Buy and Sell Stock III&lt;/a>、&lt;a class="link" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener"
>Best Time to Buy and Sell Stock IV&lt;/a>、&lt;a class="link" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener"
>Best Time to Buy and Sell Stock with Cooldown&lt;/a>和&lt;a class="link" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener"
>Best Time to Buy and Sell Stock with Transaction Fee&lt;/a>。&lt;/p>
&lt;p>我做了前三道，但是思路不连贯在第四道卡住了，在网上找第四道的题解大多是用局部最优和全局最优数组的动态规划解法，看得一知半解。直到在B站找到下面的视频，小姐姐把这六道题串连在一起，解题思路统一清晰，关键是容易理解，强烈推荐。&lt;/p>
&lt;div class="video-wrapper">
&lt;iframe src="https://player.bilibili.com/player.html?as_wide=1&amp;amp;high_quality=1&amp;amp;page=1&amp;bvid=BV1nv411P7bk"
scrolling="no"
frameborder="no"
framespacing="0"
allowfullscreen="true"
>
&lt;/iframe>
&lt;/div>
&lt;p>下面主要介绍这系列题的题意，我解前三道题的方法和补充视频里动态规划数组降维的证明。&lt;/p>
&lt;h3 id="题目大意">题目大意&lt;/h3>
&lt;p>题目的背景是已知一个数组表示每一天的股票价格&lt;code>prices&lt;/code>，可以选择某一天买入一支股票，并在之后的另一天卖掉获得盈利，同时最多只能持有一支股票。每道题都是在这个背景上增加不同的条件，求能够获得的最高盈利是多少。&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener"
>Best Time to Buy and Sell Stock&lt;/a>的条件是只能买入一次卖出一次，如果不能盈利就返回0。&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener"
>Best Time to Buy and Sell Stock II&lt;/a>的条件是可以任意买入和卖出，只要满足最多持有一支股票的限制即可。&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener"
>Best Time to Buy and Sell Stock III&lt;/a>的条件是最多只能够买入和卖出2次，&lt;a class="link" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener"
>Best Time to Buy and Sell Stock IV&lt;/a>更进一步，最多只能买入和卖出&lt;code>k&lt;/code>次。&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener"
>Best Time to Buy and Sell Stock with Cooldown&lt;/a>的条件是可以买入和卖出任意多次，但是卖出股票后必须等待一天才能够再次买入。&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener"
>Best Time to Buy and Sell Stock with Transaction Fee&lt;/a>的条件是可以买入和卖出任意多次，但是卖出股票时必须支付交易费&lt;code>fee&lt;/code>。&lt;/p>
&lt;h3 id="我解前三道题的思路">我解前三道题的思路&lt;/h3>
&lt;p>Best Time to Buy and Sell Stock的条件是只能买入和卖出一次，所以使用贪心法。维护一个买入价格&lt;code>buy&lt;/code>和盈利&lt;code>profit&lt;/code>，分别初始化为&lt;code>prices[0]&lt;/code>和0。从第一天开始遍历股票价格，如果这一天的股票价格比买入价格低，那么在这一天买入可以获得更高的盈利，更新&lt;code>buy=prices[i]&lt;/code>；如果这一天的股票价格比买入价格高，那么可以在这一天卖出，更新盈利&lt;code>profit=max(profit, prices[i]-buy)&lt;/code>。&lt;/p>
&lt;p>Best Time to Buy and Sell Stock III可以在第一题的基础上求解。题目的条件是最多可以买入和卖出2次，那么可以分为3种情况：&lt;/p>
&lt;ol>
&lt;li>不进行交易，盈利为0；&lt;/li>
&lt;li>买入和卖出1次，第一题中已经求出最高盈利；&lt;/li>
&lt;li>买入和卖出2次，假设第一次卖出发生在第&lt;code>i&lt;/code>天，那么我们可以分别对第一天到第&lt;code>i&lt;/code>天和第&lt;code>i+1&lt;/code>天到最后一天使用第一题的算法分别计算最高盈利，然后相加即可。&lt;/li>
&lt;/ol>
&lt;p>只需要考虑第三种情况，我们需要分别计算第一天到第&lt;code>i&lt;/code>天交易一次的最高盈利和第&lt;code>i&lt;/code>天到最后一天交易一次的最高盈利。对于前者，我们用数组&lt;code>fromBegin[i]&lt;/code>储存第一天到第&lt;code>i&lt;/code>天交易一次的最高盈利，仍然使用第一题的算法，只需要每一天都用&lt;code>profit&lt;/code>更新&lt;code>fromBegin[i]&lt;/code>即可。我们用数组&lt;code>toEnd[i]&lt;/code>储存第&lt;code>i&lt;/code>天到最后一天交易一次的最高盈利。把第一题的算法反过来，维护一个卖出价格&lt;code>sell&lt;/code>和盈利&lt;code>profit&lt;/code>，分别初始化为&lt;code>prices[prices.size()-1]&lt;/code>和0。从最后一天倒序遍历股票价格，如果这一天的股票价格比卖出价格高，那么在这一天卖出可以获得更高的盈利，更新&lt;code>sell=prices[i]&lt;/code>；如果这一天的股票价格比卖出价格低，那么可以在这一天买入，更新盈利&lt;code>profit=max(profix,sell-prices[i])&lt;/code>。每一天都用&lt;code>profit&lt;/code>更新&lt;code>toEnd[i]&lt;/code>。&lt;/p>
&lt;p>初始化&lt;code>profit&lt;/code>为&lt;code>fromBegin[prices.size()-1]&lt;/code>，也就是只交易一次能获得的最高盈利。然后遍历所有&lt;code>i&lt;/code>，更新&lt;code>profit=max(profit,fromBegin[i]+toEnd[i+1])&lt;/code>。最后&lt;code>profit&lt;/code>即为最高盈利。&lt;/p>
&lt;p>最后回到本题Best Time to Buy and Sell Stock II，题目不限制买入和卖出次数，但是最多只能持有一支股票。如果画出股票的价格曲线，那么要实现最大化盈利只需要在曲线的波谷买入股票，在下一个波峰卖出，然后在下一个波谷再买入，不断重复。可以用算法模拟这一过程，分别维护两个变量&lt;code>top&lt;/code>和&lt;code>bottom&lt;/code>表示价格曲线中的波峰和波谷。在一笔交易中需要先买入后卖出，所以先寻找波谷，再寻找波峰。从第一天遍历股票价格，直到当天的价格比后一天的价格低，那么这一天的价格就是波谷，接下来继续遍历，直到当天的价格比后一天的价格高，那么这一天的价格就是波峰，找到一对波谷与波峰后在盈利中加上&lt;code>top-bottom&lt;/code>，循环该过程直到遍历整个数组。&lt;/p>
&lt;h3 id="视频里数组降维的证明">视频里数组降维的证明&lt;/h3>
&lt;p>数组降维出现在视频对第二道题的讲解中(3分40秒到8分40秒)。用动态规划来解决这道题，每一天有两种状态，即有股票和没有股票。每一天的状态由前一天的状态转移而来，用&lt;code>dp[i][1]&lt;/code>和&lt;code>dp[i][0]&lt;/code>表示第&lt;code>i&lt;/code>天有股票和没有股票的盈利状态，状态转移公式如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">prices&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">prices&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为状态转移只跟前一天的状态有关系，用&lt;code>withShare&lt;/code>和&lt;code>noShare&lt;/code>分别表示有股票和没有股票的盈利状态，状态转移公式变成：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="n">noShare&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">noShare&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">withShare&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">prices&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="n">withShare&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">withShare&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">noShare&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">prices&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>评论区有人问&lt;code>noShare&lt;/code>更新完已经是第&lt;code>i&lt;/code>天的状态了，用第&lt;code>i&lt;/code>天的&lt;code>noShare&lt;/code>更新第&lt;code>i&lt;/code>天的&lt;code>withShare&lt;/code>不对啊。其实我第一次看到这里的时候也产生了相同的疑问，动态规划的状态转移公式比较好理解，后一天的状态由前一天的状态来决定，但数组降维之后后更新的变量一定需要用先更新的变量去更新，这和后一天的状态由前一天的状态来决定不矛盾吗。严格计算之后就会发现并不矛盾。&lt;/p>
&lt;p>首先观察数组降维前的状态转移公式，这两个&lt;code>max&lt;/code>看似进行了两次比较，但实际上比较的是相同的东西。不等式&lt;code>dp[i-1][1]&amp;gt;dp[i-1][0]-prices[i]&lt;/code>，把&lt;code>prices[i]&lt;/code>移项后可得&lt;code>dp[i-1][1]+prices[i]&amp;gt;dp[i-1][0]&lt;/code>。也就是说，&lt;code>dp[i-1][1]+prices[i]&lt;/code>和&lt;code>dp[i-1][0]&lt;/code>的大小关系唯一地决定了状态转移的结果。&lt;/p>
&lt;p>下面分别讨论&lt;code>dp[i-1][1]+prices[i]&lt;/code>和&lt;code>dp[i-1][0]&lt;/code>的不同大小关系对状态转移的影响。&lt;/p>
&lt;ol>
&lt;li>&lt;code>dp[i-1][1]+prices[i]&lt;/code>和&lt;code>dp[i-1][0]&lt;/code>相等。二者相等那么&lt;code>max&lt;/code>函数在两个相等的值中任取其一，选择&lt;code>dp[i][0]=dp[i-1][0]&lt;/code>和&lt;code>dp[i][1]=dp[i-1][1]&lt;/code>。对应数组降维后是&lt;code>noShare=noShare&lt;/code>和&lt;code>withShare=withShare&lt;/code>，&lt;code>withShare&lt;/code>没有用&lt;code>noShare&lt;/code>更新，所以没有影响。&lt;/li>
&lt;li>&lt;code>dp[i-1][1]+prices[i]&lt;/code>比&lt;code>dp[i-1][0]&lt;/code>大。可以得到&lt;code>dp[i][0] = dp[i-1][1]+prices[i]&lt;/code>和&lt;code>dp[i][1] = dp[i-1][i]&lt;/code>。对应数组降维后是&lt;code>noShare=withShare+prices[i]&lt;/code>和&lt;code>withShare=withShare&lt;/code>，&lt;code>withShare&lt;/code>没有用&lt;code>noShare&lt;/code>更新，所以没有影响。&lt;/li>
&lt;li>&lt;code>dp[i-1][1]+prices[i]&lt;/code>比&lt;code>dp[i-1][0]&lt;/code>小。可以得到&lt;code>dp[i][0] = dp[i-1][0]&lt;/code>和&lt;code>dp[i][1]=dp[i-1][0]-prices[i]&lt;/code>。对应数组降维后是&lt;code>noShare=noShare&lt;/code>和&lt;code>withShare=noShare-prices[i]&lt;/code>，&lt;code>withShare&lt;/code>用&lt;code>noShare&lt;/code>更新，但是这时&lt;code>noShare&lt;/code>的值还是前一天的&lt;code>noShare&lt;/code>的值，所以仍然没有影响。&lt;/li>
&lt;/ol>
&lt;p>综上所述，无论何种情况，数组降维后两种状态都能够正确更新。同样在Best Time to Buy and Sell Stock with Transaction Fee一题中，状态转移公式中虽然加上了交易费，但是两种状态还是能够正确更新。&lt;/p>
&lt;h2 id="minimum-value-to-get-positive-step-by-step-sum">Minimum Value to Get Positive Step by Step Sum&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/minimum-value-to-get-positive-step-by-step-sum/" target="_blank" rel="noopener"
>Minimum Value to Get Positive Step by Step Sum&lt;/a>题目大意：已知整型数组&lt;code>nums&lt;/code>，用一个正整数&lt;code>startValue&lt;/code>逐一累加数组中的数，为保证累加和全程不小于1，&lt;code>startValue&lt;/code>至少要是多少。&lt;/p>
&lt;p>略。&lt;/p>
&lt;h2 id="remove-linked-list-elements">Remove Linked List Elements&lt;/h2>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" >
&lt;img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg"
loading="lazy"
alt="Remove Linked List Elements">
&lt;/a>
&lt;figcaption>Remove Linked List Elements&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener"
>Remove Linked List Elements&lt;/a>题目大意：已知链表的头指针，删除链表中所有值等于给定值的结点，返回新的头指针。&lt;/p>
&lt;p>略。&lt;/p>
&lt;h2 id="daily-temperatures">Daily Temperatures&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/daily-temperatures/" target="_blank" rel="noopener"
>Daily Temperatures&lt;/a>题目大意：已知一个数组&lt;code>temperatures&lt;/code>表示每日温度，求每一天需要过多少天才能迎来更高温度，如果未来没有更高的温度，输出0。&lt;/p>
&lt;p>题意很简单，但是数据规模很大，$1 \leq temperatures.length \leq 10^5$，如果对每一天都扫描一遍数组肯定会超时。&lt;/p>
&lt;p>解这类&lt;strong>找后面第一个比自身小或者大的位置&lt;/strong>的题目，可以考虑使用单调栈，单调栈要求其中的元素保持单调性。&lt;/p>
&lt;p>维护一个栈&lt;code>stack&lt;/code>，栈内元素保存数组下标，保持的单调性为：越靠近栈顶的数组下标，对应的温度越低。&lt;/p>
&lt;p>倒序遍历数组&lt;code>temperatures&lt;/code>，遍历到第&lt;code>i&lt;/code>个元素时，如果栈非空就弹栈直到栈为空或者栈顶元素对应的温度比&lt;code>temperatures[i]&lt;/code>大。如果栈为空则记答案为0，如果栈不为空那么记答案为&lt;code>stack.top()-i&lt;/code>。最后把&lt;code>i&lt;/code>入栈。&lt;/p>
&lt;h2 id="iterator-for-combination">Iterator for Combination&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/iterator-for-combination/" target="_blank" rel="noopener"
>Iterator for Combination&lt;/a>题目大意：设计一个&lt;code>CombinationIterator&lt;/code>类，构造时传入一个由不同英文小写字母构成的有序字符串&lt;code>characters&lt;/code>和组合长度&lt;code>combinationLength&lt;/code>。该类有两个方法：&lt;code>next()&lt;/code>按字典序返回下一个长度为&lt;code>combinationLength&lt;/code>的字母组合；&lt;code>hasNext()&lt;/code>返回是否存在下一个字母组合。&lt;/p>
&lt;p>根据题意，在构造&lt;code>CombinationIterator&lt;/code>对象时，需要生成由&lt;code>characters&lt;/code>中字符构成的所有长度为&lt;code>combinationLength&lt;/code>的字母组合，并按照字典序保存在一个数组中。初始化数组下标&lt;code>index&lt;/code>为0，调用&lt;code>next()&lt;/code>方法时返回当前下标的字母组合，然后把&lt;code>index&lt;/code>加1；调用&lt;code>hasNext()&lt;/code>方法时返回&lt;code>index&lt;/code>是否小于数组大小的布尔值。&lt;/p>
&lt;h2 id="一些碎碎念">一些碎碎念&lt;/h2>
&lt;p>上一周算是我行动力最强的一周了，花了几天时间把博客从&lt;a class="link" href="https://hexo.io/" target="_blank" rel="noopener"
>Hexo&lt;/a>迁移到&lt;a class="link" href="https://gohugo.io/" target="_blank" rel="noopener"
>Hugo&lt;/a>，开始参与&lt;a class="link" href="https://leetcode.com/" target="_blank" rel="noopener"
>LeetCode&lt;/a>每日打卡领勋章活动，并记录总结。&lt;/p>
&lt;p>刷算法题我是一直不太擅长的，虽然我曾经也在博客写过很多的题解，但是现在我想换一种方式。我希望能够在尽量不贴代码的情况下用文字把解题思路描述清楚，今后自己再看的时候能够想起算法是如何实现的。现阶段这些内容可能并不适合其他读者看，毕竟在算法上文字比起代码在表达上是乏力的。幸运的是互联网上有大量分享解题思路的文章，我也仅仅是其中普通的一员罢了。&lt;/p>
&lt;p>工作之后才发现现在互联网上充斥着所谓“内容农场”的网站，每每搜索一些问题的解决办法出现在首页的都是一些机器人抓取的机翻的出处不明的文章，虽然有时候能在其中找到work的方法，但是给人的观感真的很差。也正是这些内容让我意识到重要的并非问题和答案，而是找到答案的过程。这些总结对我而言的意义正在于此，在今后遇到类似问题的时候能够举一反三，有记录可复盘。&lt;/p></description></item><item><title>LeetCode每日一题周总结(一)</title><link>https://zhangleijuly.me/p/leetcode-weekly-1/</link><pubDate>Mon, 08 Nov 2021 00:00:00 +0000</pubDate><guid>https://zhangleijuly.me/p/leetcode-weekly-1/</guid><description>&lt;img src="https://zhangleijuly.me/img/LeetCode.jpeg" alt="Featured image of post LeetCode每日一题周总结(一)" />&lt;h2 id="surrounded-regions">Surrounded Regions&lt;/h2>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg" >
&lt;img src="https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg"
loading="lazy"
alt="Surrounded Regions">
&lt;/a>
&lt;figcaption>Surrounded Regions&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/surrounded-regions/" target="_blank" rel="noopener"
>Surrounded Regions&lt;/a>题目大意：矩形棋盘上有&amp;quot;O&amp;quot;和&amp;quot;X&amp;quot;两种棋子，将所有四面被&amp;quot;X&amp;quot;包围的&amp;quot;O&amp;quot;的区域都替换为&amp;quot;X&amp;quot;(棋盘边缘不算被&amp;quot;X&amp;quot;包围)。&lt;/p>
&lt;p>一道做过的题，常规思路是遍历棋盘上所有&amp;quot;O&amp;quot;的区域，用深度优先搜索确定当前区域的范围，并判断是否满足替换条件，如果满足替换条件就进行替换，不满足替换条件就标记当前区域为已访问。这种思路能够解答该题，但是比较麻烦，需要维护额外的数据结构储存当前区域的范围，并且直到搜索遍整个当前区域后才能够确定是否需要替换。&lt;/p>
&lt;p>另一种比较巧妙的思路是反向思考，题目的含义告诉我们，不需要替换的&amp;quot;O&amp;quot;的区域都是临近棋盘边缘的，所以可以先找到这样的区域。沿着棋盘边缘寻找包含&amp;quot;O&amp;quot;的区域，同样用深度优先搜索确定这些区域的范围，这些区域就是所有不需要替换的&amp;quot;O&amp;quot;，对这些&amp;quot;O&amp;quot;做标记，把其他的&amp;quot;O&amp;quot;替换为&amp;quot;X&amp;quot;即可。&lt;/p>
&lt;h2 id="unique-paths-iii">Unique Paths III&lt;/h2>
&lt;p>前置题目为&lt;a class="link" href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener"
>Unique Paths&lt;/a>和&lt;a class="link" href="https://leetcode.com/problems/unique-paths-ii/" target="_blank" rel="noopener"
>Unique Paths II&lt;/a>。&lt;/p>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" >
&lt;img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png"
loading="lazy"
alt="Unique Paths">
&lt;/a>
&lt;figcaption>Unique Paths&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener"
>Unique Paths&lt;/a>题目大意：机器人从矩形网格左上角走到右下角，每次只能向右或者向下走一步，求不同的走法有多少种。&lt;/p>
&lt;p>使用递推法求解即可。&lt;/p>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" >
&lt;img src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg"
loading="lazy"
alt="Unique Paths II">
&lt;/a>
&lt;figcaption>Unique Paths II&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/unique-paths-ii/" target="_blank" rel="noopener"
>Unique Paths II&lt;/a>与Unique Paths题干相同，只是在网格中增加了障碍物，整体解题思路不变。&lt;/p>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2021/08/02/lc-unique1.jpg" >
&lt;img src="https://assets.leetcode.com/uploads/2021/08/02/lc-unique1.jpg"
loading="lazy"
alt="Unique Paths III">
&lt;/a>
&lt;figcaption>Unique Paths III&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/unique-paths-iii" target="_blank" rel="noopener"
>Unique Paths III&lt;/a>题干相比以上两道变化较大，起点和终点不再固定。网格上的点分为四类：起点、终点、空格和障碍物。机器人从起点出发，可以任意向四个方向移动到终点，必须通过并且仅通过每个空格一次，求不同的走法有多少种。&lt;/p>
&lt;p>可以用深度优先搜索解决，因为网格上的点只有四种，每个空格必须通过并且只能通过一次，所以每种可行的走法通过的格子数是一定的。首先扫描整个网格确定起点、终点和空格数，从起点开始搜索，初始步数为0，如果遇到障碍物或者已经踩过的空格就返回；遇到没走过的空格就标记已走过，步数加1，然后继续搜索；遇到终点就判断步数是否等于空格数，等于就返回1，否则返回0。将所有返回值相加就是最终结果。&lt;/p>
&lt;h2 id="sum-root-to-leaf-numbers">Sum Root to Leaf Numbers&lt;/h2>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg" >
&lt;img src="https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg"
loading="lazy"
alt="Sum Root to Leaf Numbers">
&lt;/a>
&lt;figcaption>Sum Root to Leaf Numbers&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener"
>Sum Root to Leaf Numbers&lt;/a>题目大意：一棵二叉树每个结点都是0~9的整数，从根结点到叶子结点的路径能够表示一个整数，例如上图的路径4-&amp;gt;9-&amp;gt;5可以表示495。求一棵这样的二叉树根结点到每一个叶子结点路径表示的整数之和。&lt;/p>
&lt;p>深度优先搜索即可，如果根结点为空直接返回0。用&lt;code>cur&lt;/code>记录根结点到当前结点路径表示的整数，初始化为0。对每一个非空结点&lt;code>root&lt;/code>，调用函数时首先更新&lt;code>cur&lt;/code>为&lt;code>cur*10+root-&amp;gt;val&lt;/code>。如果左右子树都为空，说明当前结点是叶子结点，给最终结果加上&lt;code>cur&lt;/code>；否则递归调用函数，将&lt;code>cur&lt;/code>传给非空子树。&lt;/p>
&lt;h2 id="sum-of-left-leaves">Sum of Left Leaves&lt;/h2>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg" >
&lt;img src="https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg"
loading="lazy"
alt="Sum of Left Leaves">
&lt;/a>
&lt;figcaption>Sum of Left Leaves&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener"
>Sum of Left Leaves&lt;/a>题目大意：求二叉树所有左叶子结点值的和。&lt;/p>
&lt;p>从根结点开始递归遍历每一个结点，增加一个标记位，进入左子树时传&lt;code>true&lt;/code>，进入右子树时传&lt;code>false&lt;/code>。到达叶子结点时如果标记位是&lt;code>true&lt;/code>就在最终结果加上当前结点的值。&lt;/p>
&lt;h2 id="arranging-coins">Arranging Coins&lt;/h2>
&lt;p>&lt;figure
>
&lt;a href="https://assets.leetcode.com/uploads/2021/04/09/arrangecoins2-grid.jpg" >
&lt;img src="https://assets.leetcode.com/uploads/2021/04/09/arrangecoins2-grid.jpg"
loading="lazy"
alt="Arranging Coins">
&lt;/a>
&lt;figcaption>Arranging Coins&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/arranging-coins/" target="_blank" rel="noopener"
>Arranging Coins&lt;/a>题目大意：n枚硬币按照1、2、3……逐层摆放，求摆满的层数。&lt;/p>
&lt;p>略。&lt;/p>
&lt;h2 id="single-number-iii">Single Number III&lt;/h2>
&lt;p>前置题目为&lt;a class="link" href="https://leetcode.com/problems/single-number/" target="_blank" rel="noopener"
>Single Number&lt;/a>和&lt;a class="link" href="https://leetcode.com/problems/single-number-ii/" target="_blank" rel="noopener"
>Single Number II&lt;/a>。&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/single-number/" target="_blank" rel="noopener"
>Single Number&lt;/a>题目大意：非空数组中除了一个整数外其他整数都出现偶数次，找到只出现一次的整数。&lt;/p>
&lt;p>这里利用了异或运算的性质：$a \oplus b \oplus a = b$。把整个数组异或起来结果就是要找的整数。&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/single-number-ii/" target="_blank" rel="noopener"
>Single Number II&lt;/a>题目大意：非空数组中除了一个整数外其他整数都出现3次，找到只出现一次的整数。&lt;/p>
&lt;p>常规思路是把每个整数都表示为二进制，对每一位分别求和并模3，余数所构成的二进制整数就是所求的数。进阶解法是把每一位求和模3的状态表示为0、1和2，那么下一个数这一位为0时，该状态保持不变；下一个数这一位为1时，状态将按照0-&amp;gt;1-&amp;gt;2-&amp;gt;0迁移，表示为二进制就是00-&amp;gt;01-&amp;gt;10-&amp;gt;00。分别用$B_0$和$B_1$表示二进制状态的低位和高位，$B$表示输入的这一位的值，根据状态迁移可以推导出以下关系：&lt;/p>
&lt;p>$$
B_0 = (B_0 \oplus B) \And B_1 \newline
B_1 = (B_1 \oplus B) \And B_0
$$&lt;/p>
&lt;p>应用到这道题中，就是用两个整数&lt;code>high&lt;/code>和&lt;code>low&lt;/code>分别维护二进制整数每一位的高低位状态表示，对数组中的每一个整数分别计算&lt;code>high&lt;/code>和&lt;code>low&lt;/code>，最终维护低位状态表示的整数&lt;code>low&lt;/code>即为答案。&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/single-number-iii/" target="_blank" rel="noopener"
>Single Number III&lt;/a>题目大意：非空数组中除了两个整数外其他整数都出现偶数次，找到这两个整数。&lt;/p>
&lt;p>假设这两个整数分别为$a$和$b$，利用异或运算的性质，把整个数组异或起来结果就是$a \oplus b$。$a$和$b$是不同整数，所以$a \oplus b$不为0，我们可以在$a \oplus b$的二进制表示中找到值为1的某一位。根据这一位的不同把数组分为两个数组，那么$a$和$b$一定分别在这两个数组中，并且除了$a$和$b$以外这两个数组中的其他整数都是成对出现的，接下来按照Single Number的解法就可以得到$a$和$b$。&lt;/p>
&lt;h2 id="multiply-strings">Multiply Strings&lt;/h2>
&lt;p>&lt;a class="link" href="https://leetcode.com/problems/multiply-strings/" target="_blank" rel="noopener"
>Multiply Strings&lt;/a>题目大意：已知两个表示整数的字符串，求这两个整数的乘积，也用字符串表示。&lt;/p>
&lt;p>字符串表示的大整数乘法，略。&lt;/p></description></item></channel></rss>