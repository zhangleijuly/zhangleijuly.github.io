[{"content":"Minimum Cost to Move Chips to The Same Position  Minimum Cost to Move Chips to The Same Position \nMinimum Cost to Move Chips to The Same Position题目大意：有n摞筹码，每个筹码可以以如下的方式移动：\n 以代价0向左或者向右移动2格 以代价1向左或者向右移动1格  求把所有筹码摞成一摞的最小代价。\n根据题意，所有奇数位置的筹码可以无代价移动到奇数位置，偶数位置的筹码可以无代价移动到偶数位置，在奇数位置和偶数位置之间移动才需要代价，所以只需要统计奇数位置和偶数位置的筹码数量哪种比较多。\nConvert Binary Number in a Linked List to Integer  Convert Binary Number in a Linked List to Integer \nConvert Binary Number in a Linked List to Integer题目大意：一个链表只包含0和1，把这个链表看作一个二进制数，求这个数的十进制表示。\n略。\nBinary Tree Tilt  Binary Tree Tilt \nBinary Tree Tilt题目大意：求二叉树每个节点坡度之和。二叉树节点的坡度是该节点左子树节点之和与右子树节点之和的差的绝对值。\n略。\nJump Game III 一个系列题目，一共有7道题，每道题之间的解法也不太一样。\nJump Game题目大意：已知一个数组nums，初始在第一个位置，每个位置的数字表示从这个位置最多可以跳多远，如果能到达最后一个位置，返回true，否则返回false。\n模拟题，用range表示可抵达的范围，那么最初range=0。从0开始遍历所有下标小于等于range的位置，如果可以到达更远的位置就更新range，最后判断range是否包含最后一个位置。\nJump Game II题目大意：已知一个数组nums，初始在第一个位置，每个位置的数字表示从这个位置最多可以跳多远，求最少需要多少步可以跳到最后一个位置。题目保证可以跳到最后一个位置。\n还是模拟，一步一步跳，每一个位置都有一个可以抵达的范围，在这个范围内找到跳得最远的位置作为下一步的落脚点，直到能够到达最后一个位置。\nJump Game III题目大意：已知一个数组nums，初始在位置start，每次从下标i可以跳到下标i-nums[i]或者i+nums[i]，求能不能从起始位置跳到一个值为0的位置。\n按照题意进行深度优先搜索。\nJump Game IV题目大意：已知一个数组arr，初始在第一个位置，每次可以从下标i按照如下规则跳跃：\n 当i+1\u0026lt;arr.length时跳到i+1 当i-1\u0026gt;=0时跳到i-1 当arr[i]==arr[j]并且i!=j时跳到j  求最少多少步可以跳到最后一个位置。\n需要定义几个数组，step[i]表示到下标i最少需要的步数，visited[i]表示是否到达过下标i。建立一个队列，每次找到能够到达的新的点就加入队列，这样可以保证队列里的下是按照到达步数递增排列的。建立一个hash表，对于数组中的每一个值，都记录数组里这个值的所有下标。\n初始化step[0]=0,visited[0]=true，把0加入队列。循环遍历队列，从队列中取出第一个元素x，如果这个元素是最后一个位置就跳出循环。否则先判断x-1是否访问过，如果没有访问过，更新step[x-1]=step[x]+1,visited[x-1]=true，把x-1加入队列。然后对x+1做类似操作。接下来遍历hash[arr[x]]中的所有下标，更新其中未被访问过的下标的step和visited数组，并加入队列。遍历完成后清空hash[arr[x]]。（注意：一定要清空，这是为了避免重复遍历，我就是因为没有清空所有个别样例一直超时。）循环结束后step[arr.length-1]即为所求。\nJump Game V题目大意：已知一个数组arr和一个整数d，每次可以从下标i按照如下规则跳跃：\n 如果i+x\u0026lt;arr.length并且0\u0026lt;x\u0026lt;=d，可以跳到i+x 如果i-x\u0026gt;=0并且0\u0026lt;x\u0026lt;=d，可以跳到i-x  并且从i跳到j时必须满足arr[i]\u0026gt;arr[j]和i与j之间的所有下标k都满足arr[i]\u0026gt;arr[k]。\n可以选择从任何位置开始跳跃，求最多可以访问多少个下标。\n Jump Game V \n通俗地说就是只能从高处向低处跳，最远跳跃距离是d，并且途经的位置也必须比起点低。用dp[i]表示以下标为i的位置为起点最多可以访问多少下标。那么状态转移公式为：dp[i]=max(1,max(dp[j])+1)，其中j是从i可以跳到的下标。为了保证在计算dp[i]时所有dp[j]都已经被计算过，应该把所有下标按照高度从低到高排序，然后按照排序计算dp[i]。最后取所有dp[i]中最大的。\nJump Game VI题目大意：已知一个长度为n的整型数组nums和整数k，起始下标为0，每次可以从下标i跳跃到区间[i+1,min(n-1,i+k)]中的任意下标。当跳跃到数组的最后一个下标也就是n-1的时候，你的得分是途中经过的每个下标处值之和，求可能得到的最大得分。\n用dp[i]表示在跳跃到下标i处时可以获得的最大得分，那么dp[i]=max(dp[j])+nums[i]，其中j是可以跳到i的下标。因为这道题的数据规模很大，$1 \u0026lt;= k \u0026lt;= 10^5$，所以需要一个能快速找到最大的dp[j]的方法。\n维护一个最大优先队列，把所有计算过的dp[j]都放进去，计算dp[i]的时候就从队列头部取dp[j]，如果j不能跳到i就弹出，直到j能够跳到i，用dp[j]更新dp[i]。最后dp[n-1]即为所求。\nJump Game VII题目大意：已知一个字符串s和两个整数minJump和maxJump。起始下标为0，对应字符也是'0'。符合以下条件时可以从下标i跳跃到下标j：\n i+minJump \u0026lt;= j \u0026lt;= min(i+maxJump, s.length-1) s[j]=='0'  如果能跳跃到数组最后一个位置，返回true，否则返回false。\n首先如果s[s.length-1]不是'0'可以直接返回false。其他情况我们就需要判断是不是真的能跳跃到最后一个下标。\n每次从下标i可以跳跃到的范围是[i+minJump, min(i+maxJump, s.length-1)]，如果最后一个下标在这个范围内就可以返回true，否则我们需要记录这个范围内所有s[j]=='0'的下标j用于后续的跳跃。\n用一个队列维护起跳位置，初始只有0，同时记录已经处理过的最大跳跃范围range。每次从队首弹出一个起跳位置i，那么从i跳跃范围的左边界l=i+minJump，右边界r=min(i+maxJump,s.length-1)。如果左边界l\u0026gt;s.length-1，那么返回false，因为从后续的位置只会跳得比i远，范围也不会包含最后一个下标。如果s.length-1在左右边界之间，返回true。都不是就说明还需要继续跳跃，首先更新l=max(l,range+1)，这是为了避免重复处理，只处理没有处理过的下标。把l和r之间所有为'0'的下标都加入队列，更新range=r。如果循环结束都没有返回，就说明跳得不够远，返回false。\nDomino and Tromino Tiling Domino and Tromino Tiling题目大意：求下面两种形状拼成2×n的形状有多少种方法。\n Domino and Tromino Tiling \n例如拼成2×5的形状有以下方法：\n 2×5 \n这道题是真的没想明白，直接看大神推导的递推公式吧。看到下面的评论“高中一眼看出来的公式，现在一开始以为是魔法。”真的泪目了。\nNth Magical Number Nth Magical Number题目大意：如果一个正整数能整除a或者b就称为魔数。已知n，a和b，求第n个魔数。\n魔数是有一个周期的，也就是a和b的最小公倍数lcm。任何魔数加上最小公倍数的整数倍还是魔数。一个周期内的魔数有$N = lcm/a + lcm/b -1$个。那么第n个魔数就是lcm的$\\lfloor n/N \\rfloor$倍加上第$n\\bmod N$个魔数。前者容易计算，后者可以把lcm以内所有a和b的倍数放到一个数组中排序求得。\n还有一种纯数学方法是利用魔数的分布去逼近，然后求出准确值。我专门和数院的同学讨论了一下这种方法为什么能准确地求出第x个魔数，因为它通过近似找到了不小于第x个魔数的a的倍数和b的倍数，这两个数就是第x个和第x+1个魔数。\nPartition Equal Subset Sum Partition Equal Subset Sum题目大意：已知一个由正整数构成的非空集合，求能不能把它分成两个集合，这两个集合中数字的和相等。\n这道题思路很简单，首先把集合中所有数字加起来，如果和是奇数那么肯定不可能，如果是偶数那么题目变成能不能在集合中找到一些整数加起来等于和的一半。\n能够想到用动态规划来解，用dp[i][j]表示用nums[0]到nums[i]的集合能否找到和为j的子集。那么状态转移条件是，当选择nums[i]加入子集时，如果dp[i-1][j-nums[i]]==true，那么dp[i][j]=true。当不选择nums[i]加入子集时，如果dp[i][j]==true，那么dp[i][j]=true。\n可以进行状态压缩，用dp[j]表示能否找到和为j的子集。遍历整个数组，对于每个下标i，从和的一半开始遍历j到nums[i]，如果dp[j-nums[i]]==true，那么dp[j]=true。\n","date":"2021-12-13T00:00:00Z","image":"https://zhangleijuly.me/img/LeetCode.jpeg","permalink":"https://zhangleijuly.me/p/leetcode-weekly-6/","title":"LeetCode每日一题周总结(六)"},{"content":"Accounts Merge Accounts Merge题目大意：有很多组账户信息，账户信息包括用户的名字和该用户所拥有的一个或者多个邮箱。如果两个用户拥有同一个邮箱，就说明这两个用户是同一个人。两个用户的名字相同但是不拥有同一个邮箱则认为他们是名字相同的不同用户。把所有用户相同的账户信息合并，按照题目规定的格式输出。\n用并查集解决，每个账户信息可以看作一个集合，如果两个集合中有公共的邮箱地址就合并。用一个hash表保存邮箱和集合之间的映射关系，方便快速找到出现相同邮箱的集合。\nMaximal Rectangle  Maximal Rectangle \nMaximal Rectangle题目大意：在由0和1构成的矩形中，找到最大的只由1构成的矩形，输出它的面积。\n容易想到用动态规划解决，但是方法不太容易想。用dp[i][j]表示第i行第j列之前共有多少个连续的1。状态转移关系如下：\nif (matrix[i][j] == 0) { dp[i][j] = 0; } else { if (j == 0) { dp[i][j] = 1; } else { dp[i][j] = dp[i][j-1] + 1; } } 遍历所有的坐标(i,j)，遍历所有在[i,matrix.size())之间的k，计算右上为(i,j)右下为(k,j)的最大矩形面积并更新答案。这样的矩形一边长度为(k-i+1)，另一边的长度为从i到k所有dp[i][j]的最小值。\nHouse Robber House Robber题目大意：你是一个专业的抢劫犯准备沿着一条街抢劫，已知一个数组表示这条街上每一家可以抢劫到的钱数。如果街上相邻两家被抢就会自动报警，求在不触发警报的情况下最多可以抢到多少钱。\n一道动态规划的题目。用dp[i]表示抢劫第i家时最多可以抢到多少钱，状态转移关系如下：\ndp[i] = nums[i]; if (i \u0026gt; 1) { dp[i] = nums[i]+dp[i - 2]; } if (i \u0026gt; 2) { dp[i] = max(dp[i],nums[i] + dp[i - 3]); } 至少可以保证抢到第i家的钱，如果i足够大，在不触发警报的情况下考虑前面的抢劫，只有两种情况，上一次抢劫的是第i-2家或者是第i-3家。在这几种情况中选择钱最多的更新dp[i]，并用dp[i]更新答案。\nOdd Even Linked List  Odd Even Linked List \nOdd Even Linked List题目大意：把链表中的奇数结点和偶数结点各自组织成一个链表并连接。\n考察基本的链表操作，定义奇链表和偶链表，遍历初始链表，按照奇偶把结点加入这两个链表中，最后把偶链表连接在奇链表后面。\nMaximum Product Subarray Maximum Product Subarray题目大意：求一个数组的乘积最大的子数组，返回乘积的值。子数组是指数组中连续的一部分。\n之前做过的Maximum Subarray是求和最大的子数组，这道题和它类似，区别在于最大乘积存在负负得正的情况，因此不能简单维护一个数组。维护两个数组pos[i]和neg[i]，分别表示以i为结尾的子数组乘积的最大值和最小值。状态转移关系取决于nums[i]的正负：\nif (nums[i] \u0026gt;= 0) { pos[i] = max(nums[i], pos[i - 1] * nums[i]); neg[i] = min(nums[i], neg[i - 1] * nums[i]); } else { pos[i] = max(nums[i], neg[i - 1] * nums[i]);\tneg[i] = min(nums[i], pos[i - 1] * nums[i]); } 最大的pos[i]就是答案。\nStream of Characters Stream of Characters题目大意：已知一个字典，实现一个类，该类每次从字符流中读取一个字符并能够判断字符流的后缀是否出现了字典中的单词。\n这道题用到的数据结构是Trie树，也叫做字典树，同样是之前听说过但是没有用过的。这种数据类型能够把字典储存在一棵树中，最基本的应用是查找一个字符串是否在字典中出现。在这道题中是查找字符串的后缀是否在字典中出现。\n Trie树 \n通常来说字典树可以用来查找字符串的前缀是否在字典中出现，要查找字符串的后缀是否在字典中出现就需要倒序建树并且倒序查找。\nHouse Robber III House Robber系列题型，一共包含三道题。\nHouse Robber上面已经讲过，就不再赘述。\nHouse Robber II题目大意：条件和第一题相同，区别在于街道变成了首尾相连。\n这道题在第一题算法的基础上修改一下就可以，我把情况分成了抢劫第一家和不抢劫第一家，想了很久都没有做出来。实际上首尾相连之后第一家和最后一家不能被同时抢劫了，在数组中分别删除第一项和删除最后一项，用第一题的算法各算一遍取最大的结果即可。\nHouse Robber III题目大意：这道题住宅区从线性变成了树形，劫匪要抢劫形如二叉树的区域，如果抢劫直接相连的两家就会触发警报，求在不触发警报的情况下最多可以抢劫到多少钱。\n House Robber III \n还是用动态规划，递归地为每个结点计算两个数值rob和notRob，分别表示在当前结点抢劫和不抢劫所能获得的最大金钱。如果结点为空，那么这两个数值都为0。如果结点不为空，那么当前结点的状态转移公式如下：\nroot-\u0026gt;notRob = max(root-\u0026gt;left-\u0026gt;notRob,root-\u0026gt;left-\u0026gt;rob) + max(root-\u0026gt;right-\u0026gt;notRob,root-\u0026gt;right-\u0026gt;rob); root-\u0026gt;rob = root-\u0026gt;left-\u0026gt;notRob + root-\u0026gt;right-\u0026gt;notRob + root-\u0026gt;val; 取根结点的rob和notRob的最大值就是答案。\n","date":"2021-12-05T00:00:00Z","image":"https://zhangleijuly.me/img/LeetCode.jpeg","permalink":"https://zhangleijuly.me/p/leetcode-weekly-5/","title":"LeetCode每日一题周总结(五)"},{"content":"Delete Node in a BST  Delete Node in a BST \nDelete Node in a BST题目大意：删除二叉搜索树的一个节点。\n数据结构与算法的经典问题，分三种情况：\n 该节点是叶子节点，直接删除； 该节点只有一个子节点，用子节点代替该节点位置； 该节点有两个子节点，删除该节点后，为了保持二叉搜索树的性质，应该用左子树的最大值或者右子树的最小值代替该节点。  可以参考OI Wiki。\nLargest Component Size by Common Factor  Largest Component Size by Common Factor \nLargest Component Size by Common Factor题目大意：已知一个由不同正整数构成的数组，按照如下规则构造一个无向图：\n 数组中的每个数都代表图中的一个顶点； 如果两个数存在大于1的公约数，则这两个数代表的顶点之间存在一条边。  求该图的最大连通分支中包含多少个顶点。\n这道题其实不是图论问题，而是集合划分问题，按照不同的连通分支把数组中的数划分为不同的集合，求最大的集合里有多少个数。解决这类问题用到的数据结构是并查集，并查集能够用来处理一些互不相交的集合的合并和查询的问题。并查集的定义和实现可以参考OI Wiki。\n首先需要给顶点划分集合，如果两个数存在1以外的公约数就应该把它们所在的集合合并，但是对每个数都去求它和其他所有数有没有公约数包含了很多重复的工作量。不妨换一种思路，如果我们把每个数和它的所有非1约数的集合都合并，那么两个有非1公约数的数就都跟这个公约数在同一个集合里。然后对每个顶点查找它在哪一个集合里，更新集合的大小和答案即可。\nInterval List Intersections  Interval List Intersections \nInterval List Intersections题目大意：已知两个数组，其中包含的是互不相交并且有序的闭区间，求这两个数组中区间的交集。\n这道题是贪心法的一个典型应用。对数组A和B分别维护下标i和j，i和j初始化为0。计算区间A[i]和B[j]的交集，交集的左边界是max(A[i][0],B[j][0])，右边界是min(A[i][1],B[j][1])，如果左边界大于右边界说明交集为空。然后比较两个区间的右边界，保留右边界较大的区间，将另一个区间的下标加1。如果两个区间的右边界相等，则两个下标都加1。\nMaximum Subarray Maximum Subarray题目大意：求一个数组的和最大的子数组，返回和的值。子数组是指数组中连续的一部分。\n这道题是典型的动态规划问题。用dp[i]表示以下标i结尾的子数组的和的最大值，那么有两种可能，一种是nums[i]自己构成一个子数组，另一种是它和前面的若干数构成一个子数组，这些子数组中和最大的是以下标i-1结尾的和最大的子数组再加上nums[i]，所以状态转移公式是dp[i]=max(nums[i],dp[i-1]+nums[i])。初始条件是dp[0]=nums[0]。\nSearch Insert Position Search Insert Position题目大意：已知一个包含各不相同的整数的有序数组中和一个目标值，如果能在数组中找到目标值就返回它的下标，如果不能找到就返回它插入数组中并保持数组有序时它的下标。算法时间复杂度应为$O(\\log n)$。\n看题意就知道应该用二分法，需要注意最后找不到目标数时应该返回什么下标。\nProduct of Array Except Self Product of Array Except Self题目大意：已知一个整型数组nums，求数组answer，使得answer[i]的值是nums中除nums[i]以外所有值之积。题目要求算法复杂度为$O(n)$并且不使用除法。\n自然的想法肯定是把所有数相乘然后依次除以每一个数即可，但是因为数组中可能包含0，所以这种方法本来也行不通。换一种思路，用pre[i]表示下标小于i的所有数的乘积，用post[i]表示下标大于i的所有数的乘积，那么answer[i]=pre[i]*post[i]，而求pre[i]和post[i]也只需要把数组正反各扫描一遍。\nAll Paths From Source to Target  All Paths From Source to Target \nAll Paths From Source to Target题目大意：已知一个包含n个顶点的有向无环图，求从0号顶点到n-1号顶点的所有路径。\n使用深度优先搜索即可，在搜索时记录路径，只要到达n-1号顶点就把路径加入答案。\n","date":"2021-11-28T00:00:00Z","image":"https://zhangleijuly.me/img/LeetCode.jpeg","permalink":"https://zhangleijuly.me/p/leetcode-weekly-4/","title":"LeetCode每日一题周总结(四)"},{"content":"Largest Divisible Subset Largest Divisible Subset题目大意：已知一个不同正整数组成的集合nums，求它的一个最大子集合answer，answer中任意两个整数都满足其中一个是另外一个的整数倍。\n这道题和动态规划的经典问题Longest Increasing Subsequence类似，只是把条件从大小关系变成了整除关系。\n因为只可能较大的数整除较小的数，所以要先把nums从小到大排序。接下来找到nums的满足sub[i+1]%sub[i]==0最大子序列sub就得到了答案，因为sub具有其中任意一个整数都能整除sub中比它小的整数并且被sub中比它大的整数整除的性质。\n用dp[i]存储包含nums[i]的最大子序列sub的长度，用pred[i]存储在该子序列中nums[i]的前驱在nums中的下标。对所有i\u0026lt;j，当nums[j]%nums[i]==0 \u0026amp;\u0026amp; dp[i]+1\u0026gt;dp[j]时更新dp[j]=dp[i]+1; pred[j]=i。最后根据dp找到最大的子序列和其中最大的元素，再根据pred找到所有其他元素。\nKth Smallest Number in Multiplication Table  Kth Smallest Number in Multiplication Table \nKth Smallest Number in Multiplication Table题目大意：求乘法表里第k小的数。乘法表是一个矩形表格，其中每一格中的数是这一格的行号乘列号。\n又一道题意简单但是数据规模庞大的题。这道题可以使用二分查找来降低时间复杂度，找到乘法表在1~x区间内有至少k个数的最小x即可。\n假设乘法表大小为m×n，初始化二分查找的左边界l=1，右边界r=m*n。查找时首先计算中点mid=(l+r)/2，然后计算乘法表在1到mid之间有多少数，如果有不少于k个，说明应该缩小区间，r=mid；如果不足k个，说明应该扩大区间，l=mid+1。左右边界相等时就找到了要求的x。二分查找算法模板参见AcWing。\n由于乘法表每一行都是行号的倍数，第i行就有min(n, mid/i)个数在1和mid之间，遍历每一行就可以知道乘法表中一共有多少数在1和mid之间。\nUnique Paths  Unique Paths \n这道题在LeetCode 每日一题周总结 (一)中讲到过。\nFind All Numbers Disappeared in an Array Find All Numbers Disappeared in an Array题目大意：已知一个数组大小为n，其中包含1到n之间的整数，求1到n之间有哪些整数没有在数组中出现。\n数组大小为n，其中包含的整数也在1到n之间，那么可以把数组中的整数放到对应下标的位置上去，最后遍历数组，对应下标上的数字不正确就表示缺少这个整数。\n思路很简单，但是编码过程中有不少细节。遍历数组到下标i，nums[i]对应的下标是nums[i]-1，首先检查nums[nums[i]-1]是否和nums[i]相等，如果相等就说明那个下标已经有对应的数字了，继续遍历；如果不相等就交换nums[i]和nums[nums[i]-1]，交换后nums[i]是原先在nums[nums[i]-1]处的数字，需要重新判断是否需要交换，这时需要把下标i减1，确保下次遍历还检查nums[i]。\nHamming Distance Hamming Distance题目大意：求两个整数的汉明距离。两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。\n把两个整数异或，计算结果的二进制表示中有多少位为1即可。\nSingle Element in a Sorted Array Single Element in a Sorted Array题目大意：在有序数组中有一个元素只出现一次，其余元素均成对出现，找到这个只出现一次的元素。要求时间复杂度为$O(\\log n)$，空间复杂度为$O(1)$。\n如果没有附加条件，这道题可以直接使用Single Number的方法求解。考虑到附加条件和已知数组有序，应该使用二分查找来求解。\n二分查找的关键是如何判断这个元素在左半边还是在右半边。如果没有这个元素，那么成对元素的下标应该是2n和2n+1，但是这个元素出现后，成对元素的下标就会向后偏移一位。首先确定中点下标mid，找到和mid组成(2n,2n+1)对的另一个下标，可以对mid的奇偶分类讨论，还有一种简单的方法，另一个下标是mid异或1。然后判断这两个下标对应的元素是否相等，相等就说明要找的元素还没出现，在右半边；不相等就说明要找的元素在左半边。\nConstruct Binary Tree from Inorder and Postorder Traversal  Construct Binary Tree from Inorder and Postorder Traversal \nConstruct Binary Tree from Inorder and Postorder Traversal题目大意：已知一棵树的中序遍历和后序遍历，构造出这棵树。题目保证中序遍历和后序遍历的数都唯一出现。上图为用中序遍历[9, 3, 15, 20, 7]和[9, 15, 7, 20, 3]构造的二叉树。\n可以先建立根节点，再递归地构造左子树和右子树。根节点的值是后序遍历的最后一个值，在中序遍历中找到这个值，以它为分界点把中序遍历分成左右两部分，左半边是左子树的中序遍历，右半边是右子树的中序遍历。这样就得到了左右子树的大小，根据左右子树的大小可以从后序遍历中提取出左子树的后序遍历和右子树的后序遍历。用根节点的值建立根节点，递归调用函数，用左子树的中序遍历和后序遍历生成左子树，并赋值给根节点的指针，然后再类似地生成右子树赋值给根节点的指针。最后返回根节点。\n注意边界条件，如果中序遍历和后序遍历为空，返回空指针。\n","date":"2021-11-21T00:00:00Z","image":"https://zhangleijuly.me/img/LeetCode.jpeg","permalink":"https://zhangleijuly.me/p/leetcode-weekly-3/","title":"LeetCode每日一题周总结(三)"},{"content":"Unique Binary Search Trees  Unique Binary Search Trees \nUnique Binary Search Trees题目大意：n个结点的二叉搜索树其结点的值分别为1~n，求这样的二叉搜索树有多少种不同的结构。\n刷软考题时遇到过相同问题，可以把该问题转化为规模更小的问题来求解。假设结点数为n时该问题的解为fun(n)。对于n个结点的二叉搜索树，选择1个结点作为根节点，可以选择1~n，假设我们选择m作为根节点，那么根据二叉搜索树的性质，左子树将包含1~m-1这m-1个结点，右子树将包含m+1~n这n-m个结点，以m作为根结点的二叉搜索树的结构就有fun(m-1)*fun(m-n)种。根节点的选择有n种，可以得到以下公式： $$ fun(n) = \\sum_{i=1}^n fun(i-1)*fun(n-i) $$ 为了避免重复运算，我们用数组记录结果，初始化fun[0]=1，然后从小到大依次求解fun[1]直到fun[n]即可。\nNumber of Valid Words for Each Puzzle Number of Valid Words for Each Puzzle题目大意：输入包括word和puzzle两种字符串，对于一个puzzle，满足以下条件的word是合法的：\n word包含puzzle的首字母 word中的每一个字母都在puzzle中出现  求每个puzzle分别有多少个合法的word。\n这道题题意比较简单，数据规模不大的情况下可以直接求解。但是LeetCode给出的数据规模是$1 \\leq words.length \\leq 10^5$和$1 \\leq puzzle.length \\leq 10^4$，直接求解一定会超时。\n题目的约束中，word和puzzle只包含英文小写字母。用1位二进制表示某个字母在字符串中是否出现，1表示出现，0表示未出现，只需要26位二进制整数就能表示一个字符串包含的字母集合。遍历word数组，可以求出每一个单词所包含的字母集合，因为不同的单词可能有相同的字母集合，用一个hashMap保存每一个字母集合分别构成了多少个单词。\n处理完word之后，对每个puzzle也计算出表示它所包含字母集合的整数，因为后面用到掩码操作，就用mask表示这个整数。然后需要找到符合条件的mask集合的子集subMask。\n首先subMask一定小于等于mask，但是并非所有小于等于mask的整数都是mask的子集，这时就需要用到掩码操作，对任意subMask，subMask\u0026amp;mask一定是mask的子集。用下面的循环就可以遍历所有mask的子集，掩码操作也是对这个循环的剪枝，大大减少了循环的时间代价。\nint subMask = mask; while(subMask \u0026gt; 0) { //do something  subMask = (--subMask) \u0026amp; mask; } 当然，不要忘记在subMask中必须包含puzzle的首字母。对符合条件的subMask，在hashMap中查找有多少由该字母集合构成的单词，计入结果中即可。\nBest Time to Buy and Sell Stock II 这周最有意思的有一道题，兄弟姐妹也真的多，同系列一共有6道题，包括Best Time to Buy and Sell Stock、Best Time to Buy and Sell Stock II、Best Time to Buy and Sell Stock III、Best Time to Buy and Sell Stock IV、Best Time to Buy and Sell Stock with Cooldown和Best Time to Buy and Sell Stock with Transaction Fee。\n我做了前三道，但是思路不连贯在第四道卡住了，在网上找第四道的题解大多是用局部最优和全局最优数组的动态规划解法，看得一知半解。直到在B站找到下面的视频，小姐姐把这六道题串连在一起，解题思路统一清晰，关键是容易理解，强烈推荐。\n  下面主要介绍这系列题的题意，我解前三道题的方法和补充视频里动态规划数组降维的证明。\n题目大意 题目的背景是已知一个数组表示每一天的股票价格prices，可以选择某一天买入一支股票，并在之后的另一天卖掉获得盈利，同时最多只能持有一支股票。每道题都是在这个背景上增加不同的条件，求能够获得的最高盈利是多少。\nBest Time to Buy and Sell Stock的条件是只能买入一次卖出一次，如果不能盈利就返回0。\nBest Time to Buy and Sell Stock II的条件是可以任意买入和卖出，只要满足最多持有一支股票的限制即可。\nBest Time to Buy and Sell Stock III的条件是最多只能够买入和卖出2次，Best Time to Buy and Sell Stock IV更进一步，最多只能买入和卖出k次。\nBest Time to Buy and Sell Stock with Cooldown的条件是可以买入和卖出任意多次，但是卖出股票后必须等待一天才能够再次买入。\nBest Time to Buy and Sell Stock with Transaction Fee的条件是可以买入和卖出任意多次，但是卖出股票时必须支付交易费fee。\n我解前三道题的思路 Best Time to Buy and Sell Stock的条件是只能买入和卖出一次，所以使用贪心法。维护一个买入价格buy和盈利profit，分别初始化为prices[0]和0。从第一天开始遍历股票价格，如果这一天的股票价格比买入价格低，那么在这一天买入可以获得更高的盈利，更新buy=prices[i]；如果这一天的股票价格比买入价格高，那么可以在这一天卖出，更新盈利profit=max(profit, prices[i]-buy)。\nBest Time to Buy and Sell Stock III可以在第一题的基础上求解。题目的条件是最多可以买入和卖出2次，那么可以分为3种情况：\n 不进行交易，盈利为0； 买入和卖出1次，第一题中已经求出最高盈利； 买入和卖出2次，假设第一次卖出发生在第i天，那么我们可以分别对第一天到第i天和第i+1天到最后一天使用第一题的算法分别计算最高盈利，然后相加即可。  只需要考虑第三种情况，我们需要分别计算第一天到第i天交易一次的最高盈利和第i天到最后一天交易一次的最高盈利。对于前者，我们用数组fromBegin[i]储存第一天到第i天交易一次的最高盈利，仍然使用第一题的算法，只需要每一天都用profit更新fromBegin[i]即可。我们用数组toEnd[i]储存第i天到最后一天交易一次的最高盈利。把第一题的算法反过来，维护一个卖出价格sell和盈利profit，分别初始化为prices[prices.size()-1]和0。从最后一天倒序遍历股票价格，如果这一天的股票价格比卖出价格高，那么在这一天卖出可以获得更高的盈利，更新sell=prices[i]；如果这一天的股票价格比卖出价格低，那么可以在这一天买入，更新盈利profit=max(profix,sell-prices[i])。每一天都用profit更新toEnd[i]。\n初始化profit为fromBegin[prices.size()-1]，也就是只交易一次能获得的最高盈利。然后遍历所有i，更新profit=max(profit,fromBegin[i]+toEnd[i+1])。最后profit即为最高盈利。\n最后回到本题Best Time to Buy and Sell Stock II，题目不限制买入和卖出次数，但是最多只能持有一支股票。如果画出股票的价格曲线，那么要实现最大化盈利只需要在曲线的波谷买入股票，在下一个波峰卖出，然后在下一个波谷再买入，不断重复。可以用算法模拟这一过程，分别维护两个变量top和bottom表示价格曲线中的波峰和波谷。在一笔交易中需要先买入后卖出，所以先寻找波谷，再寻找波峰。从第一天遍历股票价格，直到当天的价格比后一天的价格低，那么这一天的价格就是波谷，接下来继续遍历，直到当天的价格比后一天的价格高，那么这一天的价格就是波峰，找到一对波谷与波峰后在盈利中加上top-bottom，循环该过程直到遍历整个数组。\n视频里数组降维的证明 数组降维出现在视频对第二道题的讲解中(3分40秒到8分40秒)。用动态规划来解决这道题，每一天有两种状态，即有股票和没有股票。每一天的状态由前一天的状态转移而来，用dp[i][1]和dp[i][0]表示第i天有股票和没有股票的盈利状态，状态转移公式如下：\ndp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i]); dp[i][1] = max(dp[i-1][1],dp[i-1][0]-prices[i]); 因为状态转移只跟前一天的状态有关系，用withShare和noShare分别表示有股票和没有股票的盈利状态，状态转移公式变成：\nnoShare = max(noShare, withShare+prices[i]); withShare = max(withShare, noShare-prices[i]); 评论区有人问noShare更新完已经是第i天的状态了，用第i天的noShare更新第i天的withShare不对啊。其实我第一次看到这里的时候也产生了相同的疑问，动态规划的状态转移公式比较好理解，后一天的状态由前一天的状态来决定，但数组降维之后后更新的变量一定需要用先更新的变量去更新，这和后一天的状态由前一天的状态来决定不矛盾吗。严格计算之后就会发现并不矛盾。\n首先观察数组降维前的状态转移公式，这两个max看似进行了两次比较，但实际上比较的是相同的东西。不等式dp[i-1][1]\u0026gt;dp[i-1][0]-prices[i]，把prices[i]移项后可得dp[i-1][1]+prices[i]\u0026gt;dp[i-1][0]。也就是说，dp[i-1][1]+prices[i]和dp[i-1][0]的大小关系唯一地决定了状态转移的结果。\n下面分别讨论dp[i-1][1]+prices[i]和dp[i-1][0]的不同大小关系对状态转移的影响。\n dp[i-1][1]+prices[i]和dp[i-1][0]相等。二者相等那么max函数在两个相等的值中任取其一，选择dp[i][0]=dp[i-1][0]和dp[i][1]=dp[i-1][1]。对应数组降维后是noShare=noShare和withShare=withShare，withShare没有用noShare更新，所以没有影响。 dp[i-1][1]+prices[i]比dp[i-1][0]大。可以得到dp[i][0] = dp[i-1][1]+prices[i]和dp[i][1] = dp[i-1][i]。对应数组降维后是noShare=withShare+prices[i]和withShare=withShare，withShare没有用noShare更新，所以没有影响。 dp[i-1][1]+prices[i]比dp[i-1][0]小。可以得到dp[i][0] = dp[i-1][0]和dp[i][1]=dp[i-1][0]-prices[i]。对应数组降维后是noShare=noShare和withShare=noShare-prices[i]，withShare用noShare更新，但是这时noShare的值还是前一天的noShare的值，所以仍然没有影响。  综上所述，无论何种情况，数组降维后两种状态都能够正确更新。同样在Best Time to Buy and Sell Stock with Transaction Fee一题中，状态转移公式中虽然加上了交易费，但是两种状态还是能够正确更新。\nMinimum Value to Get Positive Step by Step Sum Minimum Value to Get Positive Step by Step Sum题目大意：已知整型数组nums，用一个正整数startValue逐一累加数组中的数，为保证累加和全程不小于1，startValue至少要是多少。\n略。\nRemove Linked List Elements  Remove Linked List Elements \nRemove Linked List Elements题目大意：已知链表的头指针，删除链表中所有值等于给定值的结点，返回新的头指针。\n略。\nDaily Temperatures Daily Temperatures题目大意：已知一个数组temperatures表示每日温度，求每一天需要过多少天才能迎来更高温度，如果未来没有更高的温度，输出0。\n题意很简单，但是数据规模很大，$1 \\leq temperatures.length \\leq 10^5$，如果对每一天都扫描一遍数组肯定会超时。\n解这类找后面第一个比自身小或者大的位置的题目，可以考虑使用单调栈，单调栈要求其中的元素保持单调性。\n维护一个栈stack，栈内元素保存数组下标，保持的单调性为：越靠近栈顶的数组下标，对应的温度越低。\n倒序遍历数组temperatures，遍历到第i个元素时，如果栈非空就弹栈直到栈为空或者栈顶元素对应的温度比temperatures[i]大。如果栈为空则记答案为0，如果栈不为空那么记答案为stack.top()-i。最后把i入栈。\nIterator for Combination Iterator for Combination题目大意：设计一个CombinationIterator类，构造时传入一个由不同英文小写字母构成的有序字符串characters和组合长度combinationLength。该类有两个方法：next()按字典序返回下一个长度为combinationLength的字母组合；hasNext()返回是否存在下一个字母组合。\n根据题意，在构造CombinationIterator对象时，需要生成由characters中字符构成的所有长度为combinationLength的字母组合，并按照字典序保存在一个数组中。初始化数组下标index为0，调用next()方法时返回当前下标的字母组合，然后把index加1；调用hasNext()方法时返回index是否小于数组大小的布尔值。\n一些碎碎念 上一周算是我行动力最强的一周了，花了几天时间把博客从Hexo迁移到Hugo，开始参与LeetCode每日打卡领勋章活动，并记录总结。\n刷算法题我是一直不太擅长的，虽然我曾经也在博客写过很多的题解，但是现在我想换一种方式。我希望能够在尽量不贴代码的情况下用文字把解题思路描述清楚，今后自己再看的时候能够想起算法是如何实现的。现阶段这些内容可能并不适合其他读者看，毕竟在算法上文字比起代码在表达上是乏力的。幸运的是互联网上有大量分享解题思路的文章，我也仅仅是其中普通的一员罢了。\n工作之后才发现现在互联网上充斥着所谓“内容农场”的网站，每每搜索一些问题的解决办法出现在首页的都是一些机器人抓取的机翻的出处不明的文章，虽然有时候能在其中找到work的方法，但是给人的观感真的很差。也正是这些内容让我意识到重要的并非问题和答案，而是找到答案的过程。这些总结对我而言的意义正在于此，在今后遇到类似问题的时候能够举一反三，有记录可复盘。\n","date":"2021-11-14T00:00:00Z","image":"https://zhangleijuly.me/img/LeetCode.jpeg","permalink":"https://zhangleijuly.me/p/leetcode-weekly-2/","title":"LeetCode每日一题周总结(二)"},{"content":"Surrounded Regions  Surrounded Regions \nSurrounded Regions题目大意：矩形棋盘上有\u0026quot;O\u0026quot;和\u0026quot;X\u0026quot;两种棋子，将所有四面被\u0026quot;X\u0026quot;包围的\u0026quot;O\u0026quot;的区域都替换为\u0026quot;X\u0026quot;(棋盘边缘不算被\u0026quot;X\u0026quot;包围)。\n一道做过的题，常规思路是遍历棋盘上所有\u0026quot;O\u0026quot;的区域，用深度优先搜索确定当前区域的范围，并判断是否满足替换条件，如果满足替换条件就进行替换，不满足替换条件就标记当前区域为已访问。这种思路能够解答该题，但是比较麻烦，需要维护额外的数据结构储存当前区域的范围，并且直到搜索遍整个当前区域后才能够确定是否需要替换。\n另一种比较巧妙的思路是反向思考，题目的含义告诉我们，不需要替换的\u0026quot;O\u0026quot;的区域都是临近棋盘边缘的，所以可以先找到这样的区域。沿着棋盘边缘寻找包含\u0026quot;O\u0026quot;的区域，同样用深度优先搜索确定这些区域的范围，这些区域就是所有不需要替换的\u0026quot;O\u0026quot;，对这些\u0026quot;O\u0026quot;做标记，把其他的\u0026quot;O\u0026quot;替换为\u0026quot;X\u0026quot;即可。\nUnique Paths III 前置题目为Unique Paths和Unique Paths II。\n Unique Paths \nUnique Paths题目大意：机器人从矩形网格左上角走到右下角，每次只能向右或者向下走一步，求不同的走法有多少种。\n使用递推法求解即可。\n Unique Paths II \nUnique Paths II与Unique Paths题干相同，只是在网格中增加了障碍物，整体解题思路不变。\n Unique Paths III \nUnique Paths III题干相比以上两道变化较大，起点和终点不再固定。网格上的点分为四类：起点、终点、空格和障碍物。机器人从起点出发，可以任意向四个方向移动到终点，必须通过并且仅通过每个空格一次，求不同的走法有多少种。\n可以用深度优先搜索解决，因为网格上的点只有四种，每个空格必须通过并且只能通过一次，所以每种可行的走法通过的格子数是一定的。首先扫描整个网格确定起点、终点和空格数，从起点开始搜索，初始步数为0，如果遇到障碍物或者已经踩过的空格就返回；遇到没走过的空格就标记已走过，步数加1，然后继续搜索；遇到终点就判断步数是否等于空格数，等于就返回1，否则返回0。将所有返回值相加就是最终结果。\nSum Root to Leaf Numbers  Sum Root to Leaf Numbers \nSum Root to Leaf Numbers题目大意：一棵二叉树每个结点都是0~9的整数，从根结点到叶子结点的路径能够表示一个整数，例如上图的路径4-\u0026gt;9-\u0026gt;5可以表示495。求一棵这样的二叉树根结点到每一个叶子结点路径表示的整数之和。\n深度优先搜索即可，如果根结点为空直接返回0。用cur记录根结点到当前结点路径表示的整数，初始化为0。对每一个非空结点root，调用函数时首先更新cur为cur*10+root-\u0026gt;val。如果左右子树都为空，说明当前结点是叶子结点，给最终结果加上cur；否则递归调用函数，将cur传给非空子树。\nSum of Left Leaves  Sum of Left Leaves \nSum of Left Leaves题目大意：求二叉树所有左叶子结点值的和。\n从根结点开始递归遍历每一个结点，增加一个标记位，进入左子树时传true，进入右子树时传false。到达叶子结点时如果标记位是true就在最终结果加上当前结点的值。\nArranging Coins  Arranging Coins \nArranging Coins题目大意：n枚硬币按照1、2、3……逐层摆放，求摆满的层数。\n略。\nSingle Number III 前置题目为Single Number和Single Number II。\nSingle Number题目大意：非空数组中除了一个整数外其他整数都出现偶数次，找到只出现一次的整数。\n这里利用了异或运算的性质：$a \\oplus b \\oplus a = b$。把整个数组异或起来结果就是要找的整数。\nSingle Number II题目大意：非空数组中除了一个整数外其他整数都出现3次，找到只出现一次的整数。\n常规思路是把每个整数都表示为二进制，对每一位分别求和并模3，余数所构成的二进制整数就是所求的数。进阶解法是把每一位求和模3的状态表示为0、1和2，那么下一个数这一位为0时，该状态保持不变；下一个数这一位为1时，状态将按照0-\u0026gt;1-\u0026gt;2-\u0026gt;0迁移，表示为二进制就是00-\u0026gt;01-\u0026gt;10-\u0026gt;00。分别用$B_0$和$B_1$表示二进制状态的低位和高位，$B$表示输入的这一位的值，根据状态迁移可以推导出以下关系：\n$$ B_0 = (B_0 \\oplus B) \\And B_1 \\newline B_1 = (B_1 \\oplus B) \\And B_0 $$\n应用到这道题中，就是用两个整数high和low分别维护二进制整数每一位的高低位状态表示，对数组中的每一个整数分别计算high和low，最终维护低位状态表示的整数low即为答案。\nSingle Number III题目大意：非空数组中除了两个整数外其他整数都出现偶数次，找到这两个整数。\n假设这两个整数分别为$a$和$b$，利用异或运算的性质，把整个数组异或起来结果就是$a \\oplus b$。$a$和$b$是不同整数，所以$a \\oplus b$不为0，我们可以在$a \\oplus b$的二进制表示中找到值为1的某一位。根据这一位的不同把数组分为两个数组，那么$a$和$b$一定分别在这两个数组中，并且除了$a$和$b$以外这两个数组中的其他整数都是成对出现的，接下来按照Single Number的解法就可以得到$a$和$b$。\nMultiply Strings Multiply Strings题目大意：已知两个表示整数的字符串，求这两个整数的乘积，也用字符串表示。\n字符串表示的大整数乘法，略。\n","date":"2021-11-08T00:00:00Z","image":"https://zhangleijuly.me/img/LeetCode.jpeg","permalink":"https://zhangleijuly.me/p/leetcode-weekly-1/","title":"LeetCode每日一题周总结(一)"}]