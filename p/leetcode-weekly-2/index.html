<!doctype html><html lang=zh-cn>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Unique Binary Search Trees Unique Binary Search Trees Unique Binary Search Trees题目大意：n个结点的二叉搜索树其结点的值分别为1~n，求这样的二叉搜索树有多少种不同的结构。 刷软考题时遇到过"><title>LeetCode每日一题周总结(二)</title>
<link rel=canonical href=https://zhangleijuly.me/p/leetcode-weekly-2/>
<link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="LeetCode每日一题周总结(二)">
<meta property="og:description" content="Unique Binary Search Trees Unique Binary Search Trees Unique Binary Search Trees题目大意：n个结点的二叉搜索树其结点的值分别为1~n，求这样的二叉搜索树有多少种不同的结构。 刷软考题时遇到过">
<meta property="og:url" content="https://zhangleijuly.me/p/leetcode-weekly-2/">
<meta property="og:site_name" content="凉城">
<meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="LeetCode"><meta property="article:published_time" content="2021-11-14T00:00:00+00:00"><meta property="article:modified_time" content="2021-11-14T00:00:00+00:00"><meta property="og:image" content="https://zhangleijuly.me/img/LeetCode.jpeg">
<meta name=twitter:title content="LeetCode每日一题周总结(二)">
<meta name=twitter:description content="Unique Binary Search Trees Unique Binary Search Trees Unique Binary Search Trees题目大意：n个结点的二叉搜索树其结点的值分别为1~n，求这样的二叉搜索树有多少种不同的结构。 刷软考题时遇到过"><meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://zhangleijuly.me/img/LeetCode.jpeg">
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-25675628-4','auto'),ga('send','pageview'))</script>
</head>
<body class="article-page has-toc">
<script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
extended">
<div id=article-toolbar>
<a href=/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>返回</span>
</a>
</div>
<main class="main full-width">
<article class="has-image main-article">
<header class=article-header>
<link rel=stylesheet href=/katex/katex.min.css>
<script defer src=/katex/katex.min.js></script>
<script defer src=/katex/contrib/auto-render.js onload=renderMathInElement(document.body)></script>
<div class=article-image>
<a href=/p/leetcode-weekly-2/>
<img src=/img/LeetCode.jpeg loading=lazy alt="Featured image of post LeetCode每日一题周总结(二)">
</a>
</div>
<div class=article-details>
<header class=article-category>
<a href=/categories/code/ style=background-color:#2a9d8f;color:#fff>
Code
</a>
</header>
<h2 class=article-title>
<a href=/p/leetcode-weekly-2/>LeetCode每日一题周总结(二)</a>
</h2>
<footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Nov 14, 2021</time>
</div>
</footer>
</div>
</header>
<section class=article-content>
<h2 id=unique-binary-search-trees>Unique Binary Search Trees</h2>
<p><figure>
<a href=https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg>
<img src=https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg loading=lazy alt="Unique Binary Search Trees">
</a>
<figcaption>Unique Binary Search Trees</figcaption>
</figure></p>
<p><a class=link href=https://leetcode.com/problems/unique-binary-search-trees/ target=_blank rel=noopener>Unique Binary Search Trees</a>题目大意：n个结点的二叉搜索树其结点的值分别为1~n，求这样的二叉搜索树有多少种不同的结构。</p>
<p>刷软考题时遇到过相同问题，可以把该问题转化为规模更小的问题来求解。假设结点数为n时该问题的解为<code>fun(n)</code>。对于n个结点的二叉搜索树，选择1个结点作为根结点，可以选择1~n，假设我们选择m作为根结点，那么根据二叉搜索树的性质，左子树将包含1~m-1这m-1个结点，右子树将包含m+1~n这n-m个结点，以m作为根结点的二叉搜索树的结构就有<code>fun(m-1)*fun(m-n)</code>种。根结点的选择有n种，可以得到以下公式：
$$
fun(n) = \sum_{i=1}^n fun(i-1)*fun(n-i)
$$
为了避免重复运算，我们用数组记录结果，初始化<code>fun[0]=1</code>，然后从小到大依次求解<code>fun[1]</code>直到<code>fun[n]</code>即可。</p>
<h2 id=number-of-valid-words-for-each-puzzle>Number of Valid Words for Each Puzzle</h2>
<p><a class=link href=https://leetcode.com/problems/number-of-valid-words-for-each-puzzle/ target=_blank rel=noopener>Number of Valid Words for Each Puzzle</a>题目大意：输入包括<code>word</code>和<code>puzzle</code>两种字符串，对于一个<code>puzzle</code>，满足以下条件的<code>word</code>是合法的：</p>
<ul>
<li><code>word</code>包含<code>puzzle</code>的首字母</li>
<li><code>word</code>中的每一个字母都在<code>puzzle</code>中出现</li>
</ul>
<p>求每个<code>puzzle</code>分别有多少个合法的<code>word</code>。</p>
<p>这道题题意比较简单，数据规模不大的情况下可以直接求解。但是LeetCode给出的数据规模是$1 \leq words.length \leq 10^5$和$1 \leq puzzle.length \leq 10^4$，直接求解一定会超时。</p>
<p>题目的约束中，<code>word</code>和<code>puzzle</code>只包含英文小写字母。用1位二进制表示某个字母在字符串中是否出现，1表示出现，0表示未出现，只需要26位二进制整数就能表示一个字符串包含的字母集合。遍历<code>word</code>数组，可以求出每一个单词所包含的字母集合，因为不同的单词可能有相同的字母集合，用一个<code>hashMap</code>保存每一个字母集合分别构成了多少个单词。</p>
<p>处理完<code>word</code>之后，对每个<code>puzzle</code>也计算出表示它所包含字母集合的整数，因为后面用到<a class=link href=https://zh.wikipedia.org/wiki/%E6%8E%A9%E7%A0%81 target=_blank rel=noopener><strong>掩码</strong></a>操作，就用<code>mask</code>表示这个整数。然后需要找到符合条件的<code>mask</code>集合的子集<code>subMask</code>。</p>
<p>首先<code>subMask</code>一定小于等于<code>mask</code>，但是并非所有小于等于<code>mask</code>的整数都是<code>mask</code>的子集，这时就需要用到<a class=link href=https://zh.wikipedia.org/wiki/%E6%8E%A9%E7%A0%81 target=_blank rel=noopener><strong>掩码</strong></a>操作，对任意<code>subMask</code>，<code>subMask&mask</code>一定是<code>mask</code>的子集。用下面的循环就可以遍历所有<code>mask</code>的子集，掩码操作也是对这个循环的剪枝，大大减少了循环的时间代价。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=kt>int</span> <span class=n>subMask</span> <span class=o>=</span> <span class=n>mask</span><span class=p>;</span>
<span class=k>while</span><span class=p>(</span><span class=n>subMask</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
<span class=p>{</span>
    <span class=c1>//do something
</span><span class=c1></span>    <span class=n>subMask</span> <span class=o>=</span> <span class=p>(</span><span class=o>--</span><span class=n>subMask</span><span class=p>)</span> <span class=o>&amp;</span> <span class=n>mask</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>当然，不要忘记在<code>subMask</code>中必须包含<code>puzzle</code>的首字母。对符合条件的<code>subMask</code>，在<code>hashMap</code>中查找有多少由该字母集合构成的单词，计入结果中即可。</p>
<h2 id=best-time-to-buy-and-sell-stock-ii>Best Time to Buy and Sell Stock II</h2>
<p>这周最有意思的有一道题，兄弟姐妹也真的多，同系列一共有6道题，包括<a class=link href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ target=_blank rel=noopener>Best Time to Buy and Sell Stock</a>、<a class=link href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ target=_blank rel=noopener>Best Time to Buy and Sell Stock II</a>、<a class=link href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/ target=_blank rel=noopener>Best Time to Buy and Sell Stock III</a>、<a class=link href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/ target=_blank rel=noopener>Best Time to Buy and Sell Stock IV</a>、<a class=link href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/ target=_blank rel=noopener>Best Time to Buy and Sell Stock with Cooldown</a>和<a class=link href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/ target=_blank rel=noopener>Best Time to Buy and Sell Stock with Transaction Fee</a>。</p>
<p>我做了前三道，但是思路不连贯在第四道卡住了，在网上找第四道的题解大多是用局部最优和全局最优数组的动态规划解法，看得一知半解。直到在B站找到下面的视频，小姐姐把这六道题串连在一起，解题思路统一清晰，关键是容易理解，强烈推荐。</p>
<div class=video-wrapper>
<iframe src="https://player.bilibili.com/player.html?as_wide=1&high_quality=1&page=1&bvid=BV1nv411P7bk" scrolling=no frameborder=no framespacing=0 allowfullscreen></iframe>
</div>
<p>下面主要介绍这系列题的题意，我解前三道题的方法和补充视频里动态规划数组降维的证明。</p>
<h3 id=题目大意>题目大意</h3>
<p>题目的背景是已知一个数组表示每一天的股票价格<code>prices</code>，可以选择某一天买入一支股票，并在之后的另一天卖掉获得盈利，同时最多只能持有一支股票。每道题都是在这个背景上增加不同的条件，求能够获得的最高盈利是多少。</p>
<p><a class=link href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ target=_blank rel=noopener>Best Time to Buy and Sell Stock</a>的条件是只能买入一次卖出一次，如果不能盈利就返回0。</p>
<p><a class=link href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ target=_blank rel=noopener>Best Time to Buy and Sell Stock II</a>的条件是可以任意买入和卖出，只要满足最多持有一支股票的限制即可。</p>
<p><a class=link href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/ target=_blank rel=noopener>Best Time to Buy and Sell Stock III</a>的条件是最多只能够买入和卖出2次，<a class=link href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/ target=_blank rel=noopener>Best Time to Buy and Sell Stock IV</a>更进一步，最多只能买入和卖出<code>k</code>次。</p>
<p><a class=link href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/ target=_blank rel=noopener>Best Time to Buy and Sell Stock with Cooldown</a>的条件是可以买入和卖出任意多次，但是卖出股票后必须等待一天才能够再次买入。</p>
<p><a class=link href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/ target=_blank rel=noopener>Best Time to Buy and Sell Stock with Transaction Fee</a>的条件是可以买入和卖出任意多次，但是卖出股票时必须支付交易费<code>fee</code>。</p>
<h3 id=我解前三道题的思路>我解前三道题的思路</h3>
<p>Best Time to Buy and Sell Stock的条件是只能买入和卖出一次，所以使用贪心法。维护一个买入价格<code>buy</code>和盈利<code>profit</code>，分别初始化为<code>prices[0]</code>和0。从第一天开始遍历股票价格，如果这一天的股票价格比买入价格低，那么在这一天买入可以获得更高的盈利，更新<code>buy=prices[i]</code>；如果这一天的股票价格比买入价格高，那么可以在这一天卖出，更新盈利<code>profit=max(profit, prices[i]-buy)</code>。</p>
<p>Best Time to Buy and Sell Stock III可以在第一题的基础上求解。题目的条件是最多可以买入和卖出2次，那么可以分为3种情况：</p>
<ol>
<li>不进行交易，盈利为0；</li>
<li>买入和卖出1次，第一题中已经求出最高盈利；</li>
<li>买入和卖出2次，假设第一次卖出发生在第<code>i</code>天，那么我们可以分别对第一天到第<code>i</code>天和第<code>i+1</code>天到最后一天使用第一题的算法分别计算最高盈利，然后相加即可。</li>
</ol>
<p>只需要考虑第三种情况，我们需要分别计算第一天到第<code>i</code>天交易一次的最高盈利和第<code>i</code>天到最后一天交易一次的最高盈利。对于前者，我们用数组<code>fromBegin[i]</code>储存第一天到第<code>i</code>天交易一次的最高盈利，仍然使用第一题的算法，只需要每一天都用<code>profit</code>更新<code>fromBegin[i]</code>即可。我们用数组<code>toEnd[i]</code>储存第<code>i</code>天到最后一天交易一次的最高盈利。把第一题的算法反过来，维护一个卖出价格<code>sell</code>和盈利<code>profit</code>，分别初始化为<code>prices[prices.size()-1]</code>和0。从最后一天倒序遍历股票价格，如果这一天的股票价格比卖出价格高，那么在这一天卖出可以获得更高的盈利，更新<code>sell=prices[i]</code>；如果这一天的股票价格比卖出价格低，那么可以在这一天买入，更新盈利<code>profit=max(profix,sell-prices[i])</code>。每一天都用<code>profit</code>更新<code>toEnd[i]</code>。</p>
<p>初始化<code>profit</code>为<code>fromBegin[prices.size()-1]</code>，也就是只交易一次能获得的最高盈利。然后遍历所有<code>i</code>，更新<code>profit=max(profit,fromBegin[i]+toEnd[i+1])</code>。最后<code>profit</code>即为最高盈利。</p>
<p>最后回到本题Best Time to Buy and Sell Stock II，题目不限制买入和卖出次数，但是最多只能持有一支股票。如果画出股票的价格曲线，那么要实现最大化盈利只需要在曲线的波谷买入股票，在下一个波峰卖出，然后在下一个波谷再买入，不断重复。可以用算法模拟这一过程，分别维护两个变量<code>top</code>和<code>bottom</code>表示价格曲线中的波峰和波谷。在一笔交易中需要先买入后卖出，所以先寻找波谷，再寻找波峰。从第一天遍历股票价格，直到当天的价格比后一天的价格低，那么这一天的价格就是波谷，接下来继续遍历，直到当天的价格比后一天的价格高，那么这一天的价格就是波峰，找到一对波谷与波峰后在盈利中加上<code>top-bottom</code>，循环该过程直到遍历整个数组。</p>
<h3 id=视频里数组降维的证明>视频里数组降维的证明</h3>
<p>数组降维出现在视频对第二道题的讲解中(3分40秒到8分40秒)。用动态规划来解决这道题，每一天有两种状态，即有股票和没有股票。每一天的状态由前一天的状态转移而来，用<code>dp[i][1]</code>和<code>dp[i][0]</code>表示第<code>i</code>天有股票和没有股票的盈利状态，状态转移公式如下：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>],</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span><span class=o>+</span><span class=n>prices</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
<span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=mi>1</span><span class=p>],</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span><span class=o>-</span><span class=n>prices</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</code></pre></div><p>因为状态转移只跟前一天的状态有关系，用<code>withShare</code>和<code>noShare</code>分别表示有股票和没有股票的盈利状态，状态转移公式变成：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=n>noShare</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=n>noShare</span><span class=p>,</span> <span class=n>withShare</span><span class=o>+</span><span class=n>prices</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
<span class=n>withShare</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=n>withShare</span><span class=p>,</span> <span class=n>noShare</span><span class=o>-</span><span class=n>prices</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</code></pre></div><p>评论区有人问<code>noShare</code>更新完已经是第<code>i</code>天的状态了，用第<code>i</code>天的<code>noShare</code>更新第<code>i</code>天的<code>withShare</code>不对啊。其实我第一次看到这里的时候也产生了相同的疑问，动态规划的状态转移公式比较好理解，后一天的状态由前一天的状态来决定，但数组降维之后后更新的变量一定需要用先更新的变量去更新，这和后一天的状态由前一天的状态来决定不矛盾吗。严格计算之后就会发现并不矛盾。</p>
<p>首先观察数组降维前的状态转移公式，这两个<code>max</code>看似进行了两次比较，但实际上比较的是相同的东西。不等式<code>dp[i-1][1]>dp[i-1][0]-prices[i]</code>，把<code>prices[i]</code>移项后可得<code>dp[i-1][1]+prices[i]>dp[i-1][0]</code>。也就是说，<code>dp[i-1][1]+prices[i]</code>和<code>dp[i-1][0]</code>的大小关系唯一地决定了状态转移的结果。</p>
<p>下面分别讨论<code>dp[i-1][1]+prices[i]</code>和<code>dp[i-1][0]</code>的不同大小关系对状态转移的影响。</p>
<ol>
<li><code>dp[i-1][1]+prices[i]</code>和<code>dp[i-1][0]</code>相等。二者相等那么<code>max</code>函数在两个相等的值中任取其一，选择<code>dp[i][0]=dp[i-1][0]</code>和<code>dp[i][1]=dp[i-1][1]</code>。对应数组降维后是<code>noShare=noShare</code>和<code>withShare=withShare</code>，<code>withShare</code>没有用<code>noShare</code>更新，所以没有影响。</li>
<li><code>dp[i-1][1]+prices[i]</code>比<code>dp[i-1][0]</code>大。可以得到<code>dp[i][0] = dp[i-1][1]+prices[i]</code>和<code>dp[i][1] = dp[i-1][i]</code>。对应数组降维后是<code>noShare=withShare+prices[i]</code>和<code>withShare=withShare</code>，<code>withShare</code>没有用<code>noShare</code>更新，所以没有影响。</li>
<li><code>dp[i-1][1]+prices[i]</code>比<code>dp[i-1][0]</code>小。可以得到<code>dp[i][0] = dp[i-1][0]</code>和<code>dp[i][1]=dp[i-1][0]-prices[i]</code>。对应数组降维后是<code>noShare=noShare</code>和<code>withShare=noShare-prices[i]</code>，<code>withShare</code>用<code>noShare</code>更新，但是这时<code>noShare</code>的值还是前一天的<code>noShare</code>的值，所以仍然没有影响。</li>
</ol>
<p>综上所述，无论何种情况，数组降维后两种状态都能够正确更新。同样在Best Time to Buy and Sell Stock with Transaction Fee一题中，状态转移公式中虽然加上了交易费，但是两种状态还是能够正确更新。</p>
<h2 id=minimum-value-to-get-positive-step-by-step-sum>Minimum Value to Get Positive Step by Step Sum</h2>
<p><a class=link href=https://leetcode.com/problems/minimum-value-to-get-positive-step-by-step-sum/ target=_blank rel=noopener>Minimum Value to Get Positive Step by Step Sum</a>题目大意：已知整型数组<code>nums</code>，用一个正整数<code>startValue</code>逐一累加数组中的数，为保证累加和全程不小于1，<code>startValue</code>至少要是多少。</p>
<p>略。</p>
<h2 id=remove-linked-list-elements>Remove Linked List Elements</h2>
<p><figure>
<a href=https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg>
<img src=https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg loading=lazy alt="Remove Linked List Elements">
</a>
<figcaption>Remove Linked List Elements</figcaption>
</figure></p>
<p><a class=link href=https://leetcode.com/problems/remove-linked-list-elements/ target=_blank rel=noopener>Remove Linked List Elements</a>题目大意：已知链表的头指针，删除链表中所有值等于给定值的结点，返回新的头指针。</p>
<p>略。</p>
<h2 id=daily-temperatures>Daily Temperatures</h2>
<p><a class=link href=https://leetcode.com/problems/daily-temperatures/ target=_blank rel=noopener>Daily Temperatures</a>题目大意：已知一个数组<code>temperatures</code>表示每日温度，求每一天需要过多少天才能迎来更高温度，如果未来没有更高的温度，输出0。</p>
<p>题意很简单，但是数据规模很大，$1 \leq temperatures.length \leq 10^5$，如果对每一天都扫描一遍数组肯定会超时。</p>
<p>解这类<strong>找后面第一个比自身小或者大的位置</strong>的题目，可以考虑使用单调栈，单调栈要求其中的元素保持单调性。</p>
<p>维护一个栈<code>stack</code>，栈内元素保存数组下标，保持的单调性为：越靠近栈顶的数组下标，对应的温度越低。</p>
<p>倒序遍历数组<code>temperatures</code>，遍历到第<code>i</code>个元素时，如果栈非空就弹栈直到栈为空或者栈顶元素对应的温度比<code>temperatures[i]</code>大。如果栈为空则记答案为0，如果栈不为空那么记答案为<code>stack.top()-i</code>。最后把<code>i</code>入栈。</p>
<h2 id=iterator-for-combination>Iterator for Combination</h2>
<p><a class=link href=https://leetcode.com/problems/iterator-for-combination/ target=_blank rel=noopener>Iterator for Combination</a>题目大意：设计一个<code>CombinationIterator</code>类，构造时传入一个由不同英文小写字母构成的有序字符串<code>characters</code>和组合长度<code>combinationLength</code>。该类有两个方法：<code>next()</code>按字典序返回下一个长度为<code>combinationLength</code>的字母组合；<code>hasNext()</code>返回是否存在下一个字母组合。</p>
<p>根据题意，在构造<code>CombinationIterator</code>对象时，需要生成由<code>characters</code>中字符构成的所有长度为<code>combinationLength</code>的字母组合，并按照字典序保存在一个数组中。初始化数组下标<code>index</code>为0，调用<code>next()</code>方法时返回当前下标的字母组合，然后把<code>index</code>加1；调用<code>hasNext()</code>方法时返回<code>index</code>是否小于数组大小的布尔值。</p>
<h2 id=一些碎碎念>一些碎碎念</h2>
<p>上一周算是我行动力最强的一周了，花了几天时间把博客从<a class=link href=https://hexo.io/ target=_blank rel=noopener>Hexo</a>迁移到<a class=link href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a>，开始参与<a class=link href=https://leetcode.com/ target=_blank rel=noopener>LeetCode</a>每日打卡领勋章活动，并记录总结。</p>
<p>刷算法题我是一直不太擅长的，虽然我曾经也在博客写过很多的题解，但是现在我想换一种方式。我希望能够在尽量不贴代码的情况下用文字把解题思路描述清楚，今后自己再看的时候能够想起算法是如何实现的。现阶段这些内容可能并不适合其他读者看，毕竟在算法上文字比起代码在表达上是乏力的。幸运的是互联网上有大量分享解题思路的文章，我也仅仅是其中普通的一员罢了。</p>
<p>工作之后才发现现在互联网上充斥着所谓“内容农场”的网站，每每搜索一些问题的解决办法出现在首页的都是一些机器人抓取的机翻的出处不明的文章，虽然有时候能在其中找到work的方法，但是给人的观感真的很差。也正是这些内容让我意识到重要的并非问题和答案，而是找到答案的过程。这些总结对我而言的意义正在于此，在今后遇到类似问题的时候能够举一反三，有记录可复盘。</p>
</section>
<footer class=article-footer>
<section class=article-tags>
<a href=/tags/leetcode/>LeetCode</a>
</section>
<section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section>
</footer>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css integrity=sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js integrity=sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script>
</article>
<aside class=related-contents--wrapper>
<h2 class=section-title>相关文章</h2>
<div class=related-contents>
<div class="flex article-list--tile">
<article class=has-image>
<a href=/p/leetcode-weekly-9/>
<div class=article-image>
<img src=/img/LeetCode.jpeg loading=lazy data-key=leetcode-weekly-9 data-hash=/img/LeetCode.jpeg>
</div>
<div class=article-details>
<h2 class=article-title>LeetCode每日一题周总结(九)</h2>
</div>
</a>
</article>
<article class=has-image>
<a href=/p/leetcode-weekly-8/>
<div class=article-image>
<img src=/img/LeetCode.jpeg loading=lazy data-key=leetcode-weekly-8 data-hash=/img/LeetCode.jpeg>
</div>
<div class=article-details>
<h2 class=article-title>LeetCode每日一题周总结(八)</h2>
</div>
</a>
</article>
<article class=has-image>
<a href=/p/leetcode-weekly-7/>
<div class=article-image>
<img src=/img/LeetCode.jpeg loading=lazy data-key=leetcode-weekly-7 data-hash=/img/LeetCode.jpeg>
</div>
<div class=article-details>
<h2 class=article-title>LeetCode每日一题周总结(七)</h2>
</div>
</a>
</article>
<article class=has-image>
<a href=/p/leetcode-weekly-6/>
<div class=article-image>
<img src=/img/LeetCode.jpeg loading=lazy data-key=leetcode-weekly-6 data-hash=/img/LeetCode.jpeg>
</div>
<div class=article-details>
<h2 class=article-title>LeetCode每日一题周总结(六)</h2>
</div>
</a>
</article>
<article class=has-image>
<a href=/p/leetcode-weekly-5/>
<div class=article-image>
<img src=/img/LeetCode.jpeg loading=lazy data-key=leetcode-weekly-5 data-hash=/img/LeetCode.jpeg>
</div>
<div class=article-details>
<h2 class=article-title>LeetCode每日一题周总结(五)</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<script src=//cdn.jsdelivr.net/npm/twikoo@1.4.11/dist/twikoo.all.min.js></script>
<div id=tcomment></div>
<style>.twikoo{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}:root[data-scheme=dark]{--twikoo-body-text-color-main:rgba(255, 255, 255, 0.9);--twikoo-body-text-color:rgba(255, 255, 255, 0.7)}.twikoo .el-input-group__prepend,.twikoo .tk-action-icon,.twikoo .tk-time,.twikoo .tk-comments-count{color:var(--twikoo-body-text-color)}.twikoo .el-input__inner,.twikoo .el-textarea__inner,.twikoo .tk-preview-container,.twikoo .tk-content,.twikoo .tk-nick,.twikoo .tk-send{color:var(--twikoo-body-text-color-main)}.twikoo .el-button{color:var(--twikoo-body-text-color)!important}</style><script>twikoo.init({envId:'twikoo-2gpvjqe49b66cf52',el:'#tcomment'})</script>
<footer class=site-footer>
<section class=copyright>
&copy;
2021 -
2022 凉城
</section>
<section class=powerby>
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> <br>
Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.5.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>
</section>
</footer>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
<aside class="sidebar right-sidebar sticky">
<section class="widget archives">
<div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
</div>
<h2 class="widget-title section-title">目录</h2>
<div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li><a href=#unique-binary-search-trees>Unique Binary Search Trees</a></li>
<li><a href=#number-of-valid-words-for-each-puzzle>Number of Valid Words for Each Puzzle</a></li>
<li><a href=#best-time-to-buy-and-sell-stock-ii>Best Time to Buy and Sell Stock II</a>
<ol>
<li><a href=#题目大意>题目大意</a></li>
<li><a href=#我解前三道题的思路>我解前三道题的思路</a></li>
<li><a href=#视频里数组降维的证明>视频里数组降维的证明</a></li>
</ol>
</li>
<li><a href=#minimum-value-to-get-positive-step-by-step-sum>Minimum Value to Get Positive Step by Step Sum</a></li>
<li><a href=#remove-linked-list-elements>Remove Linked List Elements</a></li>
<li><a href=#daily-temperatures>Daily Temperatures</a></li>
<li><a href=#iterator-for-combination>Iterator for Combination</a></li>
<li><a href=#一些碎碎念>一些碎碎念</a></li>
</ol>
</nav>
</div>
</section>
</aside>
</div>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
</body>
</html>