[{"content":"Delete Node in a BST  Delete Node in a BST \nDelete Node in a BST题目大意：删除二叉搜索树的一个节点。\n数据结构与算法的经典问题，分三种情况：\n 该节点是叶子节点，直接删除； 该节点只有一个子节点，用子节点代替该节点位置； 该节点有两个子节点，删除该节点后，为了保持二叉搜索树的性质，应该用左子树的最大值或者右子树的最小值代替该节点。  可以参考OI Wiki。\nLargest Component Size by Common Factor  Largest Component Size by Common Factor \nLargest Component Size by Common Factor题目大意：已知一个由不同正整数构成的数组，按照如下规则构造一个无向图：\n 数组中的每个数都代表图中的一个顶点； 如果两个数存在大于1的公约数，则这两个数代表的顶点之间存在一条边。  求该图的最大连通分支中包含多少个顶点。\n这道题其实不是图论问题，而是集合划分问题，按照不同的连通分支把数组中的数划分为不同的集合，求最大的集合里有多少个数。解决这类问题用到的数据结构是并查集，并查集能够用来处理一些互不相交的集合的合并和查询的问题。并查集的定义和实现可以参考OI Wiki。\n首先需要给顶点划分集合，如果两个数存在1以外的公约数就应该把它们所在的集合合并，但是对每个数都去求它和其他所有数有没有公约数包含了很多重复的工作量。不妨换一种思路，如果我们把每个数和它的所有非1约数的集合都合并，那么两个有非1公约数的数就都跟这个公约数在同一个集合里。然后对每个顶点查找它在哪一个集合里，更新集合的大小和答案即可。\nInterval List Intersections  Interval List Intersections \nInterval List Intersections题目大意：已知两个数组，其中包含的是互不相交并且有序的闭区间，求这两个数组中区间的交集。\n这道题是贪心法的一个典型应用。对数组A和B分别维护下标i和j，i和j初始化为0。计算区间A[i]和B[j]的交集，交集的左边界是max(A[i][0],B[j][0])，右边界是min(A[i][1],B[j][1])，如果左边界大于右边界说明交集为空。然后比较两个区间的右边界，保留右边界较大的区间，将另一个区间的下标加1。如果两个区间的右边界相等，则两个下标都加1。\nMaximum Subarray Maximum Subarray题目大意：求一个数组的和最大的子数组，返回和的值。子数组是指数组中连续的一部分。\n这道题是典型的动态规划问题。用dp[i]表示以下标i结尾的子数组的和的最大值，那么有两种可能，一种是nums[i]自己构成一个子数组，另一种是它和前面的若干数构成一个子数组，这些子数组中和最大的是以下标i-1结尾的和最大的子数组再加上nums[i]，所以状态转移公式是dp[i]=max(nums[i],dp[i-1]+nums[i])。初始条件是dp[0]=nums[0]。\nSearch Insert Position Search Insert Position题目大意：已知一个包含各不相同的整数的有序数组中和一个目标值，如果能在数组中找到目标值就返回它的下标，如果不能找到就返回它插入数组中并保持数组有序时它的下标。算法时间复杂度应为$O(\\log n)$。\n看题意就知道应该用二分法，需要注意最后找不到目标数时应该返回什么下标。\nProduct of Array Except Self Product of Array Except Self题目大意：已知一个整型数组nums，求数组answer，使得answer[i]的值是nums中除nums[i]以外所有值之积。题目要求算法复杂度为$O(n)$并且不使用除法。\n自然的想法肯定是把所有数相乘然后依次除以每一个数即可，但是因为数组中可能包含0，所以这种方法本来也行不通。换一种思路，用pre[i]表示下标小于i的所有数的乘积，用post[i]表示下标大于i的所有数的乘积，那么answer[i]=pre[i]*post[i]，而求pre[i]和post[i]也只需要把数组正反各扫描一遍。\nAll Paths From Source to Target  All Paths From Source to Target \nAll Paths From Source to Target题目大意：已知一个包含n个顶点的有向无环图，求从0号顶点到n-1号顶点的所有路径。\n使用深度优先搜索即可，在搜索时记录路径，只要到达n-1号顶点就把路径加入答案。\n","date":"2021-11-28T00:00:00Z","image":"https://zhangleijuly.me/img/LeetCode.jpeg","permalink":"https://zhangleijuly.me/p/leetcode-weekly-4/","title":"LeetCode每日一题周总结(四)"},{"content":"Largest Divisible Subset Largest Divisible Subset题目大意：已知一个不同正整数组成的集合nums，求它的一个最大子集合answer，answer中任意两个整数都满足其中一个是另外一个的整数倍。\n这道题和动态规划的经典问题Longest Increasing Subsequence类似，只是把条件从大小关系变成了整除关系。\n因为只可能较大的数整除较小的数，所以要先把nums从小到大排序。接下来找到nums的满足sub[i+1]%sub[i]==0最大子序列sub就得到了答案，因为sub具有其中任意一个整数都能整除sub中比它小的整数并且被sub中比它大的整数整除的性质。\n用dp[i]存储包含nums[i]的最大子序列sub的长度，用pred[i]存储在该子序列中nums[i]的前驱在nums中的下标。对所有i\u0026lt;j，当nums[j]%nums[i]==0 \u0026amp;\u0026amp; dp[i]+1\u0026gt;dp[j]时更新dp[j]=dp[i]+1; pred[j]=i。最后根据dp找到最大的子序列和其中最大的元素，再根据pred找到所有其他元素。\nKth Smallest Number in Multiplication Table  Kth Smallest Number in Multiplication Table \nKth Smallest Number in Multiplication Table题目大意：求乘法表里第k小的数。乘法表是一个矩形表格，其中每一格中的数是这一格的行号乘列号。\n又一道题意简单但是数据规模庞大的题。这道题可以使用二分查找来降低时间复杂度，找到乘法表在1~x区间内有至少k个数的最小x即可。\n假设乘法表大小为m×n，初始化二分查找的左边界l=1，右边界r=m*n。查找时首先计算中点mid=(l+r)/2，然后计算乘法表在1到mid之间有多少数，如果有不少于k个，说明应该缩小区间，r=mid；如果不足k个，说明应该扩大区间，l=mid+1。左右边界相等时就找到了要求的x。二分查找算法模板参见AcWing。\n由于乘法表每一行都是行号的倍数，第i行就有min(n, mid/i)个数在1和mid之间，遍历每一行就可以知道乘法表中一共有多少数在1和mid之间。\nUnique Paths  Unique Paths \n这道题在LeetCode 每日一题周总结 (一)中讲到过。\nFind All Numbers Disappeared in an Array Find All Numbers Disappeared in an Array题目大意：已知一个数组大小为n，其中包含1到n之间的整数，求1到n之间有哪些整数没有在数组中出现。\n数组大小为n，其中包含的整数也在1到n之间，那么可以把数组中的整数放到对应下标的位置上去，最后遍历数组，对应下标上的数字不正确就表示缺少这个整数。\n思路很简单，但是编码过程中有不少细节。遍历数组到下标i，nums[i]对应的下标是nums[i]-1，首先检查nums[nums[i]-1]是否和nums[i]相等，如果相等就说明那个下标已经有对应的数字了，继续遍历；如果不相等就交换nums[i]和nums[nums[i]-1]，交换后nums[i]是原先在nums[nums[i]-1]处的数字，需要重新判断是否需要交换，这时需要把下标i减1，确保下次遍历还检查nums[i]。\nHamming Distance Hamming Distance题目大意：求两个整数的汉明距离。两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。\n把两个整数异或，计算结果的二进制表示中有多少位为1即可。\nSingle Element in a Sorted Array Single Element in a Sorted Array题目大意：在有序数组中有一个元素只出现一次，其余元素均成对出现，找到这个只出现一次的元素。要求时间复杂度为$O(\\log n)$，空间复杂度为$O(1)$。\n如果没有附加条件，这道题可以直接使用Single Number的方法求解。考虑到附加条件和已知数组有序，应该使用二分查找来求解。\n二分查找的关键是如何判断这个元素在左半边还是在右半边。如果没有这个元素，那么成对元素的下标应该是2n和2n+1，但是这个元素出现后，成对元素的下标就会向后偏移一位。首先确定中点下标mid，找到和mid组成(2n,2n+1)对的另一个下标，可以对mid的奇偶分类讨论，还有一种简单的方法，另一个下标是mid异或1。然后判断这两个下标对应的元素是否相等，相等就说明要找的元素还没出现，在右半边；不相等就说明要找的元素在左半边。\nConstruct Binary Tree from Inorder and Postorder Traversal  Construct Binary Tree from Inorder and Postorder Traversal \nConstruct Binary Tree from Inorder and Postorder Traversal题目大意：已知一棵树的中序遍历和后序遍历，构造出这棵树。题目保证中序遍历和后序遍历的数都唯一出现。上图为用中序遍历[9, 3, 15, 20, 7]和[9, 15, 7, 20, 3]构造的二叉树。\n可以先建立根节点，再递归地构造左子树和右子树。根节点的值是后序遍历的最后一个值，在中序遍历中找到这个值，以它为分界点把中序遍历分成左右两部分，左半边是左子树的中序遍历，右半边是右子树的中序遍历。这样就得到了左右子树的大小，根据左右子树的大小可以从后序遍历中提取出左子树的后序遍历和右子树的后序遍历。用根节点的值建立根节点，递归调用函数，用左子树的中序遍历和后序遍历生成左子树，并赋值给根节点的指针，然后再类似地生成右子树赋值给根节点的指针。最后返回根节点。\n注意边界条件，如果中序遍历和后序遍历为空，返回空指针。\n","date":"2021-11-21T00:00:00Z","image":"https://zhangleijuly.me/img/LeetCode.jpeg","permalink":"https://zhangleijuly.me/p/leetcode-weekly-3/","title":"LeetCode每日一题周总结(三)"},{"content":"Unique Binary Search Trees  Unique Binary Search Trees \nUnique Binary Search Trees题目大意：n个结点的二叉搜索树其结点的值分别为1~n，求这样的二叉搜索树有多少种不同的结构。\n刷软考题时遇到过相同问题，可以把该问题转化为规模更小的问题来求解。假设结点数为n时该问题的解为fun(n)。对于n个结点的二叉搜索树，选择1个结点作为根节点，可以选择1~n，假设我们选择m作为根节点，那么根据二叉搜索树的性质，左子树将包含1~m-1这m-1个结点，右子树将包含m+1~n这n-m个结点，以m作为根结点的二叉搜索树的结构就有fun(m-1)*fun(m-n)种。根节点的选择有n种，可以得到以下公式： $$ fun(n) = \\sum_{i=1}^n fun(i-1)*fun(n-i) $$ 为了避免重复运算，我们用数组记录结果，初始化fun[0]=1，然后从小到大依次求解fun[1]直到fun[n]即可。\nNumber of Valid Words for Each Puzzle Number of Valid Words for Each Puzzle题目大意：输入包括word和puzzle两种字符串，对于一个puzzle，满足以下条件的word是合法的：\n word包含puzzle的首字母 word中的每一个字母都在puzzle中出现  求每个puzzle分别有多少个合法的word。\n这道题题意比较简单，数据规模不大的情况下可以直接求解。但是LeetCode给出的数据规模是$1 \\leq words.length \\leq 10^5$和$1 \\leq puzzle.length \\leq 10^4$，直接求解一定会超时。\n题目的约束中，word和puzzle只包含英文小写字母。用1位二进制表示某个字母在字符串中是否出现，1表示出现，0表示未出现，只需要26位二进制整数就能表示一个字符串包含的字母集合。遍历word数组，可以求出每一个单词所包含的字母集合，因为不同的单词可能有相同的字母集合，用一个hashMap保存每一个字母集合分别构成了多少个单词。\n处理完word之后，对每个puzzle也计算出表示它所包含字母集合的整数，因为后面用到掩码操作，就用mask表示这个整数。然后需要找到符合条件的mask集合的子集subMask。\n首先subMask一定小于等于mask，但是并非所有小于等于mask的整数都是mask的子集，这时就需要用到掩码操作，对任意subMask，subMask\u0026amp;mask一定是mask的子集。用下面的循环就可以遍历所有mask的子集，掩码操作也是对这个循环的剪枝，大大减少了循环的时间代价。\nint subMask = mask; while(subMask \u0026gt; 0) { //do something  subMask = (--subMask) \u0026amp; mask; } 当然，不要忘记在subMask中必须包含puzzle的首字母。对符合条件的subMask，在hashMap中查找有多少由该字母集合构成的单词，计入结果中即可。\nBest Time to Buy and Sell Stock II 这周最有意思的有一道题，兄弟姐妹也真的多，同系列一共有6道题，包括Best Time to Buy and Sell Stock、Best Time to Buy and Sell Stock II、Best Time to Buy and Sell Stock III、Best Time to Buy and Sell Stock IV、Best Time to Buy and Sell Stock with Cooldown和Best Time to Buy and Sell Stock with Transaction Fee。\n我做了前三道，但是思路不连贯在第四道卡住了，在网上找第四道的题解大多是用局部最优和全局最优数组的动态规划解法，看得一知半解。直到在B站找到下面的视频，小姐姐把这六道题串连在一起，解题思路统一清晰，关键是容易理解，强烈推荐。\n  下面主要介绍这系列题的题意，我解前三道题的方法和补充视频里动态规划数组降维的证明。\n题目大意 题目的背景是已知一个数组表示每一天的股票价格prices，可以选择某一天买入一支股票，并在之后的另一天卖掉获得盈利，同时最多只能持有一支股票。每道题都是在这个背景上增加不同的条件，求能够获得的最高盈利是多少。\nBest Time to Buy and Sell Stock的条件是只能买入一次卖出一次，如果不能盈利就返回0。\nBest Time to Buy and Sell Stock II的条件是可以任意买入和卖出，只要满足最多持有一支股票的限制即可。\nBest Time to Buy and Sell Stock III的条件是最多只能够买入和卖出2次，Best Time to Buy and Sell Stock IV更进一步，最多只能买入和卖出k次。\nBest Time to Buy and Sell Stock with Cooldown的条件是可以买入和卖出任意多次，但是卖出股票后必须等待一天才能够再次买入。\nBest Time to Buy and Sell Stock with Transaction Fee的条件是可以买入和卖出任意多次，但是卖出股票时必须支付交易费fee。\n我解前三道题的思路 Best Time to Buy and Sell Stock的条件是只能买入和卖出一次，所以使用贪心法。维护一个买入价格buy和盈利profit，分别初始化为prices[0]和0。从第一天开始遍历股票价格，如果这一天的股票价格比买入价格低，那么在这一天买入可以获得更高的盈利，更新buy=prices[i]；如果这一天的股票价格比买入价格高，那么可以在这一天卖出，更新盈利profit=max(profit, prices[i]-buy)。\nBest Time to Buy and Sell Stock III可以在第一题的基础上求解。题目的条件是最多可以买入和卖出2次，那么可以分为3种情况：\n 不进行交易，盈利为0； 买入和卖出1次，第一题中已经求出最高盈利； 买入和卖出2次，假设第一次卖出发生在第i天，那么我们可以分别对第一天到第i天和第i+1天到最后一天使用第一题的算法分别计算最高盈利，然后相加即可。  只需要考虑第三种情况，我们需要分别计算第一天到第i天交易一次的最高盈利和第i天到最后一天交易一次的最高盈利。对于前者，我们用数组fromBegin[i]储存第一天到第i天交易一次的最高盈利，仍然使用第一题的算法，只需要每一天都用profit更新fromBegin[i]即可。我们用数组toEnd[i]储存第i天到最后一天交易一次的最高盈利。把第一题的算法反过来，维护一个卖出价格sell和盈利profit，分别初始化为prices[prices.size()-1]和0。从最后一天倒序遍历股票价格，如果这一天的股票价格比卖出价格高，那么在这一天卖出可以获得更高的盈利，更新sell=prices[i]；如果这一天的股票价格比卖出价格低，那么可以在这一天买入，更新盈利profit=max(profix,sell-prices[i])。每一天都用profit更新toEnd[i]。\n初始化profit为fromBegin[prices.size()-1]，也就是只交易一次能获得的最高盈利。然后遍历所有i，更新profit=max(profit,fromBegin[i]+toEnd[i+1])。最后profit即为最高盈利。\n最后回到本题Best Time to Buy and Sell Stock II，题目不限制买入和卖出次数，但是最多只能持有一支股票。如果画出股票的价格曲线，那么要实现最大化盈利只需要在曲线的波谷买入股票，在下一个波峰卖出，然后在下一个波谷再买入，不断重复。可以用算法模拟这一过程，分别维护两个变量top和bottom表示价格曲线中的波峰和波谷。在一笔交易中需要先买入后卖出，所以先寻找波谷，再寻找波峰。从第一天遍历股票价格，直到当天的价格比后一天的价格低，那么这一天的价格就是波谷，接下来继续遍历，直到当天的价格比后一天的价格高，那么这一天的价格就是波峰，找到一对波谷与波峰后在盈利中加上top-bottom，循环该过程直到遍历整个数组。\n视频里数组降维的证明 数组降维出现在视频对第二道题的讲解中(3分40秒到8分40秒)。用动态规划来解决这道题，每一天有两种状态，即有股票和没有股票。每一天的状态由前一天的状态转移而来，用dp[i][1]和dp[i][0]表示第i天有股票和没有股票的盈利状态，状态转移公式如下：\ndp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i]); dp[i][1] = max(dp[i-1][1],dp[i-1][0]-prices[i]); 因为状态转移只跟前一天的状态有关系，用withShare和noShare分别表示有股票和没有股票的盈利状态，状态转移公式变成：\nnoShare = max(noShare, withShare+prices[i]); withShare = max(withShare, noShare-prices[i]); 评论区有人问noShare更新完已经是第i天的状态了，用第i天的noShare更新第i天的withShare不对啊。其实我第一次看到这里的时候也产生了相同的疑问，动态规划的状态转移公式比较好理解，后一天的状态由前一天的状态来决定，但数组降维之后后更新的变量一定需要用先更新的变量去更新，这和后一天的状态由前一天的状态来决定不矛盾吗。严格计算之后就会发现并不矛盾。\n首先观察数组降维前的状态转移公式，这两个max看似进行了两次比较，但实际上比较的是相同的东西。不等式dp[i-1][1]\u0026gt;dp[i-1][0]-prices[i]，把prices[i]移项后可得dp[i-1][1]+prices[i]\u0026gt;dp[i-1][0]。也就是说，dp[i-1][1]+prices[i]和dp[i-1][0]的大小关系唯一地决定了状态转移的结果。\n下面分别讨论dp[i-1][1]+prices[i]和dp[i-1][0]的不同大小关系对状态转移的影响。\n dp[i-1][1]+prices[i]和dp[i-1][0]相等。二者相等那么max函数在两个相等的值中任取其一，选择dp[i][0]=dp[i-1][0]和dp[i][1]=dp[i-1][1]。对应数组降维后是noShare=noShare和withShare=withShare，withShare没有用noShare更新，所以没有影响。 dp[i-1][1]+prices[i]比dp[i-1][0]大。可以得到dp[i][0] = dp[i-1][1]+prices[i]和dp[i][1] = dp[i-1][i]。对应数组降维后是noShare=withShare+prices[i]和withShare=withShare，withShare没有用noShare更新，所以没有影响。 dp[i-1][1]+prices[i]比dp[i-1][0]小。可以得到dp[i][0] = dp[i-1][0]和dp[i][1]=dp[i-1][0]-prices[i]。对应数组降维后是noShare=noShare和withShare=noShare-prices[i]，withShare用noShare更新，但是这时noShare的值还是前一天的noShare的值，所以仍然没有影响。  综上所述，无论何种情况，数组降维后两种状态都能够正确更新。同样在Best Time to Buy and Sell Stock with Transaction Fee一题中，状态转移公式中虽然加上了交易费，但是两种状态还是能够正确更新。\nMinimum Value to Get Positive Step by Step Sum Minimum Value to Get Positive Step by Step Sum题目大意：已知整型数组nums，用一个正整数startValue逐一累加数组中的数，为保证累加和全程不小于1，startValue至少要是多少。\n略。\nRemove Linked List Elements  Remove Linked List Elements \nRemove Linked List Elements题目大意：已知链表的头指针，删除链表中所有值等于给定值的结点，返回新的头指针。\n略。\nDaily Temperatures Daily Temperatures题目大意：已知一个数组temperatures表示每日温度，求每一天需要过多少天才能迎来更高温度，如果未来没有更高的温度，输出0。\n题意很简单，但是数据规模很大，$1 \\leq temperatures.length \\leq 10^5$，如果对每一天都扫描一遍数组肯定会超时。\n解这类找后面第一个比自身小或者大的位置的题目，可以考虑使用单调栈，单调栈要求其中的元素保持单调性。\n维护一个栈stack，栈内元素保存数组下标，保持的单调性为：越靠近栈顶的数组下标，对应的温度越低。\n倒序遍历数组temperatures，遍历到第i个元素时，如果栈非空就弹栈直到栈为空或者栈顶元素对应的温度比temperatures[i]大。如果栈为空则记答案为0，如果栈不为空那么记答案为stack.top()-i。最后把i入栈。\nIterator for Combination Iterator for Combination题目大意：设计一个CombinationIterator类，构造时传入一个由不同英文小写字母构成的有序字符串characters和组合长度combinationLength。该类有两个方法：next()按字典序返回下一个长度为combinationLength的字母组合；hasNext()返回是否存在下一个字母组合。\n根据题意，在构造CombinationIterator对象时，需要生成由characters中字符构成的所有长度为combinationLength的字母组合，并按照字典序保存在一个数组中。初始化数组下标index为0，调用next()方法时返回当前下标的字母组合，然后把index加1；调用hasNext()方法时返回index是否小于数组大小的布尔值。\n一些碎碎念 上一周算是我行动力最强的一周了，花了几天时间把博客从Hexo迁移到Hugo，开始参与LeetCode每日打卡领勋章活动，并记录总结。\n刷算法题我是一直不太擅长的，虽然我曾经也在博客写过很多的题解，但是现在我想换一种方式。我希望能够在尽量不贴代码的情况下用文字把解题思路描述清楚，今后自己再看的时候能够想起算法是如何实现的。现阶段这些内容可能并不适合其他读者看，毕竟在算法上文字比起代码在表达上是乏力的。幸运的是互联网上有大量分享解题思路的文章，我也仅仅是其中普通的一员罢了。\n工作之后才发现现在互联网上充斥着所谓“内容农场”的网站，每每搜索一些问题的解决办法出现在首页的都是一些机器人抓取的机翻的出处不明的文章，虽然有时候能在其中找到work的方法，但是给人的观感真的很差。也正是这些内容让我意识到重要的并非问题和答案，而是找到答案的过程。这些总结对我而言的意义正在于此，在今后遇到类似问题的时候能够举一反三，有记录可复盘。\n","date":"2021-11-14T00:00:00Z","image":"https://zhangleijuly.me/img/LeetCode.jpeg","permalink":"https://zhangleijuly.me/p/leetcode-weekly-2/","title":"LeetCode每日一题周总结(二)"},{"content":"Surrounded Regions  Surrounded Regions \nSurrounded Regions题目大意：矩形棋盘上有\u0026quot;O\u0026quot;和\u0026quot;X\u0026quot;两种棋子，将所有四面被\u0026quot;X\u0026quot;包围的\u0026quot;O\u0026quot;的区域都替换为\u0026quot;X\u0026quot;(棋盘边缘不算被\u0026quot;X\u0026quot;包围)。\n一道做过的题，常规思路是遍历棋盘上所有\u0026quot;O\u0026quot;的区域，用深度优先搜索确定当前区域的范围，并判断是否满足替换条件，如果满足替换条件就进行替换，不满足替换条件就标记当前区域为已访问。这种思路能够解答该题，但是比较麻烦，需要维护额外的数据结构储存当前区域的范围，并且直到搜索遍整个当前区域后才能够确定是否需要替换。\n另一种比较巧妙的思路是反向思考，题目的含义告诉我们，不需要替换的\u0026quot;O\u0026quot;的区域都是临近棋盘边缘的，所以可以先找到这样的区域。沿着棋盘边缘寻找包含\u0026quot;O\u0026quot;的区域，同样用深度优先搜索确定这些区域的范围，这些区域就是所有不需要替换的\u0026quot;O\u0026quot;，对这些\u0026quot;O\u0026quot;做标记，把其他的\u0026quot;O\u0026quot;替换为\u0026quot;X\u0026quot;即可。\nUnique Paths III 前置题目为Unique Paths和Unique Paths II。\n Unique Paths \nUnique Paths题目大意：机器人从矩形网格左上角走到右下角，每次只能向右或者向下走一步，求不同的走法有多少种。\n使用递推法求解即可。\n Unique Paths II \nUnique Paths II与Unique Paths题干相同，只是在网格中增加了障碍物，整体解题思路不变。\n Unique Paths III \nUnique Paths III题干相比以上两道变化较大，起点和终点不再固定。网格上的点分为四类：起点、终点、空格和障碍物。机器人从起点出发，可以任意向四个方向移动到终点，必须通过并且仅通过每个空格一次，求不同的走法有多少种。\n可以用深度优先搜索解决，因为网格上的点只有四种，每个空格必须通过并且只能通过一次，所以每种可行的走法通过的格子数是一定的。首先扫描整个网格确定起点、终点和空格数，从起点开始搜索，初始步数为0，如果遇到障碍物或者已经踩过的空格就返回；遇到没走过的空格就标记已走过，步数加1，然后继续搜索；遇到终点就判断步数是否等于空格数，等于就返回1，否则返回0。将所有返回值相加就是最终结果。\nSum Root to Leaf Numbers  Sum Root to Leaf Numbers \nSum Root to Leaf Numbers题目大意：一棵二叉树每个结点都是0~9的整数，从根结点到叶子结点的路径能够表示一个整数，例如上图的路径4-\u0026gt;9-\u0026gt;5可以表示495。求一棵这样的二叉树根结点到每一个叶子结点路径表示的整数之和。\n深度优先搜索即可，如果根结点为空直接返回0。用cur记录根结点到当前结点路径表示的整数，初始化为0。对每一个非空结点root，调用函数时首先更新cur为cur*10+root-\u0026gt;val。如果左右子树都为空，说明当前结点是叶子结点，给最终结果加上cur；否则递归调用函数，将cur传给非空子树。\nSum of Left Leaves  Sum of Left Leaves \nSum of Left Leaves题目大意：求二叉树所有左叶子结点值的和。\n从根结点开始递归遍历每一个结点，增加一个标记位，进入左子树时传true，进入右子树时传false。到达叶子结点时如果标记位是true就在最终结果加上当前结点的值。\nArranging Coins  Arranging Coins \nArranging Coins题目大意：n枚硬币按照1、2、3……逐层摆放，求摆满的层数。\n略。\nSingle Number III 前置题目为Single Number和Single Number II。\nSingle Number题目大意：非空数组中除了一个整数外其他整数都出现偶数次，找到只出现一次的整数。\n这里利用了异或运算的性质：$a \\oplus b \\oplus a = b$。把整个数组异或起来结果就是要找的整数。\nSingle Number II题目大意：非空数组中除了一个整数外其他整数都出现3次，找到只出现一次的整数。\n常规思路是把每个整数都表示为二进制，对每一位分别求和并模3，余数所构成的二进制整数就是所求的数。进阶解法是把每一位求和模3的状态表示为0、1和2，那么下一个数这一位为0时，该状态保持不变；下一个数这一位为1时，状态将按照0-\u0026gt;1-\u0026gt;2-\u0026gt;0迁移，表示为二进制就是00-\u0026gt;01-\u0026gt;10-\u0026gt;00。分别用$B_0$和$B_1$表示二进制状态的低位和高位，$B$表示输入的这一位的值，根据状态迁移可以推导出以下关系：\n$$ B_0 = (B_0 \\oplus B) \\And B_1 \\newline B_1 = (B_1 \\oplus B) \\And B_0 $$\n应用到这道题中，就是用两个整数high和low分别维护二进制整数每一位的高低位状态表示，对数组中的每一个整数分别计算high和low，最终维护低位状态表示的整数low即为答案。\nSingle Number III题目大意：非空数组中除了两个整数外其他整数都出现偶数次，找到这两个整数。\n假设这两个整数分别为$a$和$b$，利用异或运算的性质，把整个数组异或起来结果就是$a \\oplus b$。$a$和$b$是不同整数，所以$a \\oplus b$不为0，我们可以在$a \\oplus b$的二进制表示中找到值为1的某一位。根据这一位的不同把数组分为两个数组，那么$a$和$b$一定分别在这两个数组中，并且除了$a$和$b$以外这两个数组中的其他整数都是成对出现的，接下来按照Single Number的解法就可以得到$a$和$b$。\nMultiply Strings Multiply Strings题目大意：已知两个表示整数的字符串，求这两个整数的乘积，也用字符串表示。\n字符串表示的大整数乘法，略。\n","date":"2021-11-08T00:00:00Z","image":"https://zhangleijuly.me/img/LeetCode.jpeg","permalink":"https://zhangleijuly.me/p/leetcode-weekly-1/","title":"LeetCode每日一题周总结(一)"}]