[{"content":"Unique Binary Search Trees  Unique Binary Search Trees \nUnique Binary Search Trees题目大意：n个结点的二叉搜索树其结点的值分别为1~n，求这样的二叉搜索树有多少种不同的结构。\n刷软考题时遇到过相同问题，可以把该问题转化为规模更小的问题来求解。假设结点数为n时该问题的解为fun(n)。对于n个结点的二叉搜索树，选择1个结点作为根节点，可以选择1~n，假设我们选择m作为根节点，那么根据二叉搜索树的性质，左子树将包含1~m-1这m-1个结点，右子树将包含m+1~n这n-m个结点，以m作为根结点的二叉搜索树的结构就有fun(m-1)*fun(m-n)种。根节点的选择有n种，可以得到以下公式： $$ fun(n) = \\sum_{i=1}^n fun(i-1)*fun(n-i) $$ 为了避免重复运算，我们用数组记录结果，初始化fun[0]=1，然后从小到大依次求解fun[1]直到fun[n]即可。\nNumber of Valid Words for Each Puzzle Number of Valid Words for Each Puzzle题目大意：输入包括word和puzzle两种字符串，对于一个puzzle，满足以下条件的word是合法的：\n word包含puzzle的首字母 word中的每一个字母都在puzzle中出现  求每个puzzle分别有多少个合法的word。\n这道题题意比较简单，数据规模不大的情况下可以直接求解。但是LeetCode给出的数据规模是$1 \\leq words.length \\leq 10^5$和$1 \\leq puzzle.length \\leq 10^4$，直接求解一定会超时。\n题目的约束中，word和puzzle只包含英文小写字母。用1位二进制表示某个字母在字符串中是否出现，1表示出现，0表示未出现，只需要26位二进制整数就能表示一个字符串包含的字母集合。遍历word数组，可以求出每一个单词所包含的字母集合，因为不同的单词可能有相同的字母集合，用一个hashMap保存每一个字母集合分别构成了多少个单词。\n处理完word之后，对每个puzzle也计算出表示它所包含字母集合的整数，因为后面用到掩码操作，就用mask表示这个整数。然后需要找到符合条件的mask集合的子集subMask。\n首先subMask一定小于等于mask，但是并非所有小于等于mask的整数都是mask的子集，这时就需要用到掩码操作，对任意subMask，subMask\u0026amp;mask一定是mask的子集。用下面的循环就可以遍历所有mask的子集，掩码操作也是对这个循环的剪枝，大大减少了循环的时间代价。\nint subMask = mask; while(subMask \u0026gt; 0) { //do something  subMask = (--subMask) \u0026amp; mask; } 当然，不要忘记在subMask中必须包含puzzle的首字母。对符合条件的subMask，在hashMap中查找有多少由该字母集合构成的单词，计入结果中即可。\nBest Time to Buy and Sell Stock II 这周最有意思的有一道题，兄弟姐妹也真的多，同系列一共有6道题，包括Best Time to Buy and Sell Stock、Best Time to Buy and Sell Stock II、Best Time to Buy and Sell Stock III、Best Time to Buy and Sell Stock IV、Best Time to Buy and Sell Stock with Cooldown和Best Time to Buy and Sell Stock with Transaction Fee。\n我做了前三道，但是思路不连贯在第四道卡住了，在网上找第四道的题解大多是用局部最优和全局最优数组的动态规划解法，看得一知半解。直到在B站找到下面的视频，小姐姐把这六道题串连在一起，解题思路统一清晰，关键是容易理解，强烈推荐。\n  下面主要介绍这系列题的题意，我解前三道题的方法和补充视频里动态规划数组降维的证明。\n题目大意 题目的背景是已知一个数组表示每一天的股票价格prices，可以选择某一天买入一支股票，并在之后的另一天卖掉获得盈利，同时最多只能持有一支股票。每道题都是在这个背景上增加不同的条件，求能够获得的最高盈利是多少。\nBest Time to Buy and Sell Stock的条件是只能买入一次卖出一次，如果不能盈利就返回0。\nBest Time to Buy and Sell Stock II的条件是可以任意买入和卖出，只要满足最多持有一支股票的限制即可。\nBest Time to Buy and Sell Stock III的条件是最多只能够买入和卖出2次，Best Time to Buy and Sell Stock IV更进一步，最多只能买入和卖出k次。\nBest Time to Buy and Sell Stock with Cooldown的条件是可以买入和卖出任意多次，但是卖出股票后必须等待一天才能够再次买入。\nBest Time to Buy and Sell Stock with Transaction Fee的条件是可以买入和卖出任意多次，但是卖出股票时必须支付交易费fee。\n我解前三道题的思路 Best Time to Buy and Sell Stock的条件是只能买入和卖出一次，所以使用贪心法。维护一个买入价格buy和盈利profit，分别初始化为prices[0]和0。从第一天开始遍历股票价格，如果这一天的股票价格比买入价格低，那么在这一天买入可以获得更高的盈利，更新buy=prices[i]；如果这一天的股票价格比买入价格高，那么可以在这一天卖出，更新盈利profit=max(profit, prices[i]-buy)。\nBest Time to Buy and Sell Stock III可以在第一题的基础上求解。题目的条件是最多可以买入和卖出2次，那么可以分为3种情况：\n 不进行交易，盈利为0； 买入和卖出1次，第一题中已经求出最高盈利； 买入和卖出2次，假设第一次卖出发生在第i天，那么我们可以分别对第一天到第i天和第i+1天到最后一天使用第一题的算法分别计算最高盈利，然后相加即可。  只需要考虑第三种情况，我们需要分别计算第一天到第i天交易一次的最高盈利和第i天到最后一天交易一次的最高盈利。对于前者，我们用数组fromBegin[i]储存第一天到第i天交易一次的最高盈利，仍然使用第一题的算法，只需要每一天都用profit更新fromBegin[i]即可。我们用数组toEnd[i]储存第i天到最后一天交易一次的最高盈利。把第一题的算法反过来，维护一个卖出价格sell和盈利profit，分别初始化为prices[prices.size()-1]和0。从最后一天倒序遍历股票价格，如果这一天的股票价格比卖出价格高，那么在这一天卖出可以获得更高的盈利，更新sell=prices[i]；如果这一天的股票价格比卖出价格低，那么可以在这一天买入，更新盈利profit=max(profix,sell-prices[i])。每一天都用profit更新toEnd[i]。\n初始化profit为fromBegin[prices.size()-1]，也就是只交易一次能获得的最高盈利。然后遍历所有i，更新profit=max(profit,fromBegin[i]+toEnd[i+1])。最后profit即为最高盈利。\n最后回到本题Best Time to Buy and Sell Stock II，题目不限制买入和卖出次数，但是最多只能持有一支股票。如果画出股票的价格曲线，那么要实现最大化盈利只需要在曲线的波谷买入股票，在下一个波峰卖出，然后在下一个波谷再买入，不断重复。可以用算法模拟这一过程，分别维护两个变量top和bottom表示价格曲线中的波峰和波谷。在一笔交易中需要先买入后卖出，所以先寻找波谷，再寻找波峰。从第一天遍历股票价格，直到当天的价格比后一天的价格低，那么这一天的价格就是波谷，接下来继续遍历，直到当天的价格比后一天的价格高，那么这一天的价格就是波峰，找到一对波谷与波峰后在盈利中加上top-bottom，循环该过程直到遍历整个数组。\n视频里数组降维的证明 数组降维出现在视频对第二道题的讲解中(3分40秒到8分40秒)。用动态规划来解决这道题，每一天有两种状态，即有股票和没有股票。每一天的状态由前一天的状态转移而来，用dp[i][1]和dp[i][0]表示第i天有股票和没有股票的盈利状态，状态转移公式如下：\ndp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i]); dp[i][1] = max(dp[i-1][1],dp[i-1][0]-prices[i]); 因为状态转移只跟前一天的状态有关系，用withShare和noShare分别表示有股票和没有股票的盈利状态，状态转移公式变成：\nnoShare = max(noShare, withShare+prices[i]); withShare = max(withShare, noShare-prices[i]); 评论区有人问noShare更新完已经是第i天的状态了，用第i天的noShare更新第i天的withShare不对啊。其实我第一次看到这里的时候也产生了相同的疑问，动态规划的状态转移公式比较好理解，后一天的状态由前一天的状态来决定，但数组降维之后后更新的变量一定需要用先更新的变量去更新，这和后一天的状态由前一天的状态来决定不矛盾吗。严格计算之后就会发现并不矛盾。\n首先观察数组降维前的状态转移公式，这两个max看似进行了两次比较，但实际上比较的是相同的东西。不等式dp[i-1][1]\u0026gt;dp[i-1][0]-prices[i]，把prices[i]移项后可得dp[i-1][1]+prices[i]\u0026gt;dp[i-1][0]。也就是说，dp[i-1][1]+prices[i]和dp[i-1][0]的大小关系唯一地决定了状态转移的结果。\n下面分别讨论dp[i-1][1]+prices[i]和dp[i-1][0]的不同大小关系对状态转移的影响。\n dp[i-1][1]+prices[i]和dp[i-1][0]相等。二者相等那么max函数在两个相等的值中任取其一，选择dp[i][0]=dp[i-1][0]和dp[i][1]=dp[i-1][1]。对应数组降维后是noShare=noShare和withShare=withShare，withShare没有用noShare更新，所以没有影响。 dp[i-1][1]+prices[i]比dp[i-1][0]大。可以得到dp[i][0] = dp[i-1][1]+prices[i]和dp[i][1] = dp[i-1][i]。对应数组降维后是noShare=withShare+prices[i]和withShare=withShare，withShare没有用noShare更新，所以没有影响。 dp[i-1][1]+prices[i]比dp[i-1][0]小。可以得到dp[i][0] = dp[i-1][0]和dp[i][1]=dp[i-1][0]-prices[i]。对应数组降维后是noShare=noShare和withShare=noShare-prices[i]，withShare用noShare更新，但是这时noShare的值还是前一天的noShare的值，所以仍然没有影响。  综上所述，无论何种情况，数组降维后两种状态都能够正确更新。同样在Best Time to Buy and Sell Stock with Transaction Fee一题中，状态转移公式中虽然加上了交易费，但是两种状态还是能够正确更新。\nMinimum Value to Get Positive Step by Step Sum Minimum Value to Get Positive Step by Step Sum题目大意：已知整型数组nums，用一个正整数startValue逐一累加数组中的数，为保证累加和全程不小于1，startValue至少要是多少。\n略。\nRemove Linked List Elements Remove Linked List Elements题目大意：已知链表的头指针，删除链表中所有值等于给定值的结点，返回新的头指针。\n略。\nDaily Temperatures Daily Temperatures题目大意：已知一个数组temperatures表示每日温度，求每一天需要过多少天才能迎来更高温度，如果未来没有更高的温度，输出0。\n题意很简单，但是数据规模很大，$1 \\leq temperatures.length \\leq 10^5$，如果对每一天都扫描一遍数组肯定会超时。\n解这类找后面第一个比自身小或者大的位置的题目，可以考虑使用单调栈，单调栈要求其中的元素保持单调性。\n维护一个栈stack，栈内元素保存数组下标，保持的单调性为：越靠近栈顶的数组下标，对应的温度越低。\n倒序遍历数组temperatures，遍历到第i个元素时，如果栈非空就弹栈直到栈为空或者栈顶元素对应的温度比temperatures[i]大。如果栈为空则记答案为0，如果栈不为空那么记答案为stack.top()-i。最后把i入栈。\nIterator for Combination Iterator for Combination题目大意：设计一个CombinationIterator类，构造时传入一个由不同英文小写字母构成的有序字符串characters和组合长度combinationLength。该类有两个方法：next()按字典序返回下一个长度为combinationLength的字母组合；hasNext()返回是否存在下一个字母组合。\n根据题意，在构造CombinationIterator对象时，需要生成由characters中字符构成的所有长度为combinationLength的字母组合，并按照字典序保存在一个数组中。初始化数组下标index为0，调用next()方法时返回当前下标的字母组合，然后把index加1；调用hasNext()方法时返回index是否小于数组大小的布尔值。\n一些碎碎念 上一周算是我行动力最强的一周了，花了几天时间把博客从Hexo迁移到Hugo，开始参与LeetCode每日打卡领勋章活动，并记录总结。\n刷算法题我是一直不太擅长的，虽然我曾经也在博客写过很多的题解，但是现在我想换一种方式。我希望能够在尽量不贴代码的情况下用文字把解题思路描述清楚，今后自己再看的时候能够想起算法是如何实现的。现阶段这些内容可能并不适合其他读者看，毕竟在算法上文字比起代码在表达上是乏力的。幸运的是互联网上有大量分享解题思路的文章，我也仅仅是其中普通的一员罢了。\n工作之后才发现现在互联网上充斥着所谓“内容农场”的网站，每每搜索一些问题的解决办法出现在首页的都是一些机器人抓取的机翻的出处不明的文章，虽然有时候能在其中找到work的方法，但是给人的观感真的很差。也正是这些内容让我意识到重要的并非问题和答案，而是找到答案的过程。这些总结对我而言的意义正在于此，在今后遇到类似问题的时候能够举一反三，有记录可复盘。\n","date":"2021-11-14T00:00:00Z","image":"https://zhangleijuly.me/img/LeetCode.jpeg","permalink":"https://zhangleijuly.me/p/leetcode-weekly-2/","title":"LeetCode每日一题周总结(二)"},{"content":"Surrounded Regions  Surrounded Regions \nSurrounded Regions题目大意：矩形棋盘上有\u0026quot;O\u0026quot;和\u0026quot;X\u0026quot;两种棋子，将所有四面被\u0026quot;X\u0026quot;包围的\u0026quot;O\u0026quot;的区域都替换为\u0026quot;X\u0026quot;(棋盘边缘不算被\u0026quot;X\u0026quot;包围)。\n一道做过的题，常规思路是遍历棋盘上所有\u0026quot;O\u0026quot;的区域，用深度优先搜索确定当前区域的范围，并判断是否满足替换条件，如果满足替换条件就进行替换，不满足替换条件就标记当前区域为已访问。这种思路能够解答该题，但是比较麻烦，需要维护额外的数据结构储存当前区域的范围，并且直到搜索遍整个当前区域后才能够确定是否需要替换。\n另一种比较巧妙的思路是反向思考，题目的含义告诉我们，不需要替换的\u0026quot;O\u0026quot;的区域都是临近棋盘边缘的，所以可以先找到这样的区域。沿着棋盘边缘寻找包含\u0026quot;O\u0026quot;的区域，同样用深度优先搜索确定这些区域的范围，这些区域就是所有不需要替换的\u0026quot;O\u0026quot;，对这些\u0026quot;O\u0026quot;做标记，把其他的\u0026quot;O\u0026quot;替换为\u0026quot;X\u0026quot;即可。\nUnique Paths III 前置题目为Unique Paths和Unique Paths II。\n Unique Paths \nUnique Paths题目大意：机器人从矩形网格左上角走到右下角，每次只能向右或者向下走一步，求不同的走法有多少种。\n使用递推法求解即可。\n Unique Paths II \nUnique Paths II与Unique Paths题干相同，只是在网格中增加了障碍物，整体解题思路不变。\n Unique Paths III \nUnique Paths III题干相比以上两道变化较大，起点和终点不再固定。网格上的点分为四类：起点、终点、空格和障碍物。机器人从起点出发，可以任意向四个方向移动到终点，必须通过并且仅通过每个空格一次，求不同的走法有多少种。\n可以用深度优先搜索解决，因为网格上的点只有四种，每个空格必须通过并且只能通过一次，所以每种可行的走法通过的格子数是一定的。首先扫描整个网格确定起点、终点和空格数，从起点开始搜索，初始步数为0，如果遇到障碍物或者已经踩过的空格就返回；遇到没走过的空格就标记已走过，步数加1，然后继续搜索；遇到终点就判断步数是否等于空格数，等于就返回1，否则返回0。将所有返回值相加就是最终结果。\nSum Root to Leaf Numbers  Sum Root to Leaf Numbers \nSum Root to Leaf Numbers题目大意：一棵二叉树每个结点都是0~9的整数，从根结点到叶子结点的路径能够表示一个整数，例如上图的路径4-\u0026gt;9-\u0026gt;5可以表示495。求一棵这样的二叉树根结点到每一个叶子结点路径表示的整数之和。\n深度优先搜索即可，如果根结点为空直接返回0。用cur记录根结点到当前结点路径表示的整数，初始化为0。对每一个非空结点root，调用函数时首先更新cur为cur*10+root-\u0026gt;val。如果左右子树都为空，说明当前结点是叶子结点，给最终结果加上cur；否则递归调用函数，将cur传给非空子树。\nSum of Left Leaves  Sum of Left Leaves \nSum of Left Leaves题目大意：求二叉树所有左叶子结点值的和。\n从根结点开始递归遍历每一个结点，增加一个标记位，进入左子树时传true，进入右子树时传false。到达叶子结点时如果标记位是true就在最终结果加上当前结点的值。\nArranging Coins  Arranging Coins \nArranging Coins题目大意：n枚硬币按照1、2、3……逐层摆放，求摆满的层数。\n略。\nSingle Number III 前置题目为Single Number和Single Number II。\nSingle Number题目大意：非空数组中除了一个整数外其他整数都出现偶数次，找到只出现一次的整数。\n这里利用了异或运算的性质：a⊕b⊕a=b。把整个数组异或起来结果就是要找的整数。\nSingle Number II题目大意：非空数组中除了一个整数外其他整数都出现3次，找到只出现一次的整数。\n常规思路是把每个整数都表示为二进制，对每一位分别求和并模3，余数所构成的二进制整数就是所求的数。进阶解法是把每一位求和模3的状态表示为0、1和2，那么下一个数这一位为0时，该状态保持不变；下一个数这一位为1时，状态将按照0-\u0026gt;1-\u0026gt;2-\u0026gt;0迁移，表示为二进制就是00-\u0026gt;01-\u0026gt;10-\u0026gt;00。分别用$B_0$和$B_1$表示二进制状态的低位和高位，$B$表示输入的这一位的值，根据状态迁移可以推导出以下关系：\n$$ B_0 = (B_0 \\oplus B) \\And B_1 \\newline B_1 = (B_1 \\oplus B) \\And B_0 $$\n应用到这道题中，就是用两个整数high和low分别维护二进制整数每一位的高低位状态表示，对数组中的每一个整数分别计算high和low，最终维护低位状态表示的整数low即为答案。\nSingle Number III题目大意：非空数组中除了两个整数外其他整数都出现偶数次，找到这两个整数。\n假设这两个整数分别为a和b，利用异或运算的性质，把整个数组异或起来结果就是a⊕b。a和b是不同整数，所以a⊕b不为0，我们可以在a⊕b的二进制表示中找到值为1的某一位。根据这一位的不同把数组分为两个数组，那么a和b一定分别在这两个数组中，并且除了a和b以外这两个数组中的其他整数都是成对出现的，接下来按照Single Number的解法就可以得到a和b。\nMultiply Strings Multiply Strings题目大意：已知两个表示整数的字符串，求这两个整数的乘积，也用字符串表示。\n字符串表示的大整数乘法，略。\n","date":"2021-11-08T00:00:00Z","image":"https://zhangleijuly.me/img/LeetCode.jpeg","permalink":"https://zhangleijuly.me/p/leetcode-weekly-1/","title":"LeetCode每日一题周总结(一)"}]